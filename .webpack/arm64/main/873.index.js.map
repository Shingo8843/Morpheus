{"version":3,"file":"873.index.js","mappings":"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","sources":["webpack://morpheus/./node_modules/@orama/orama/dist/components/defaults.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/hooks.js","webpack://morpheus/./node_modules/@orama/orama/dist/types.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/sync-blocking-checker.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/tokenizer/languages.js","webpack://morpheus/./node_modules/@orama/orama/dist/errors.js","webpack://morpheus/./node_modules/@orama/orama/dist/methods/insert.js","webpack://morpheus/./node_modules/@orama/orama/dist/utils.js"],"sourcesContent":["import { createError } from '../errors.js';\nimport { formatNanoseconds, uniqueId } from '../utils.js';\nexport { getDocumentProperties } from '../utils.js';\nexport async function formatElapsedTime(n) {\n    return {\n        raw: Number(n),\n        formatted: await formatNanoseconds(n)\n    };\n}\nexport async function getDocumentIndexId(doc) {\n    if (doc.id) {\n        if (typeof doc.id !== 'string') {\n            throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof doc.id);\n        }\n        return doc.id;\n    }\n    return await uniqueId();\n}\nexport async function validateSchema(doc, schema) {\n    for (const [prop, type] of Object.entries(schema)){\n        const value = doc[prop];\n        if (typeof value === 'undefined') {\n            continue;\n        }\n        if (type === 'geopoint' && typeof value === 'object' && typeof value.lon === 'number' && typeof value.lat === 'number') {\n            continue;\n        }\n        if (type === 'enum' && (typeof value === 'string' || typeof value === 'number')) {\n            continue;\n        }\n        if (type === 'enum[]' && Array.isArray(value)) {\n            const valueLength = value.length;\n            for(let i = 0; i < valueLength; i++){\n                if (typeof value[i] !== 'string' && typeof value[i] !== 'number') {\n                    return prop + '.' + i;\n                }\n            }\n            continue;\n        }\n        if (isVectorType(type)) {\n            const vectorSize = getVectorSize(type);\n            if (!Array.isArray(value) || value.length !== vectorSize) {\n                throw createError('INVALID_INPUT_VECTOR', prop, vectorSize, value.length);\n            }\n            continue;\n        }\n        if (isArrayType(type)) {\n            if (!Array.isArray(value)) {\n                return prop;\n            }\n            const expectedType = getInnerType(type);\n            const valueLength = value.length;\n            for(let i = 0; i < valueLength; i++){\n                if (typeof value[i] !== expectedType) {\n                    return prop + '.' + i;\n                }\n            }\n            continue;\n        }\n        if (typeof type === 'object') {\n            if (!value || typeof value !== 'object') {\n                return prop;\n            }\n            // using as ResultDocument is not exactly right but trying to be type-safe here is not useful\n            const subProp = await validateSchema(value, type);\n            if (subProp) {\n                return prop + '.' + subProp;\n            }\n            continue;\n        }\n        if (typeof value !== type) {\n            return prop;\n        }\n    }\n    return undefined;\n}\nconst IS_ARRAY_TYPE = {\n    string: false,\n    number: false,\n    boolean: false,\n    enum: false,\n    geopoint: false,\n    'string[]': true,\n    'number[]': true,\n    'boolean[]': true,\n    'enum[]': true\n};\nconst INNER_TYPE = {\n    'string[]': 'string',\n    'number[]': 'number',\n    'boolean[]': 'boolean',\n    'enum[]': 'enum'\n};\nexport function isGeoPointType(type) {\n    return type === 'geopoint';\n}\nexport function isVectorType(type) {\n    return typeof type === 'string' && /^vector\\[\\d+\\]$/.test(type);\n}\nexport function isArrayType(type) {\n    return typeof type === 'string' && IS_ARRAY_TYPE[type];\n}\nexport function getInnerType(type) {\n    return INNER_TYPE[type];\n}\nexport function getVectorSize(type) {\n    const size = Number(type.slice(7, -1));\n    switch(true){\n        case isNaN(size):\n            throw createError('INVALID_VECTOR_VALUE', type);\n        case size <= 0:\n            throw createError('INVALID_VECTOR_SIZE', type);\n        default:\n            return size;\n    }\n}\n\n//# sourceMappingURL=defaults.js.map","export const OBJECT_COMPONENTS = [\n    'tokenizer',\n    'index',\n    'documentsStore',\n    'sorter'\n];\nexport const FUNCTION_COMPONENTS = [\n    'validateSchema',\n    'getDocumentIndexId',\n    'getDocumentProperties',\n    'formatElapsedTime'\n];\nexport const SINGLE_OR_ARRAY_COMPONENTS = [];\nexport async function runSingleHook(hooks, orama, id, doc) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](orama, id, doc);\n    }\n}\nexport async function runMultipleHook(hooks, orama, docsOrIds) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](orama, docsOrIds);\n    }\n}\nexport async function runAfterSearch(hooks, db, params, language, results) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](db, params, language, results);\n    }\n}\nexport async function runBeforeSearch(hooks, db, params, language) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](db, params, language);\n    }\n}\n\n//# sourceMappingURL=hooks.js.map","export const kInsertions = Symbol('orama.insertions');\nexport const kRemovals = Symbol('orama.removals');\n\n//# sourceMappingURL=types.js.map","var _globalThis_process;\nimport { kInsertions, kRemovals } from '../types.js';\n// Web platforms don't have process. React-Native doesn't have process.emitWarning.\nconst warn = ((_globalThis_process = globalThis.process) === null || _globalThis_process === void 0 ? void 0 : _globalThis_process.emitWarning) ?? function emitWarning(message, options) {\n    console.warn(`[WARNING] [${options.code}] ${message}`);\n};\nexport function trackInsertion(orama) {\n    if (typeof orama[kInsertions] !== 'number') {\n        queueMicrotask(()=>{\n            orama[kInsertions] = undefined;\n        });\n        orama[kInsertions] = 0;\n    }\n    if (orama[kInsertions] > 1000) {\n        warn(\"Orama's insert operation is synchronous. Please avoid inserting a large number of document in a single operation in order not to block the main thread or, in alternative, please use insertMultiple.\", {\n            code: 'ORAMA0001'\n        });\n        orama[kInsertions] = -1;\n    } else if (orama[kInsertions] >= 0) {\n        orama[kInsertions]++;\n    }\n}\nexport function trackRemoval(orama) {\n    if (typeof orama[kRemovals] !== 'number') {\n        queueMicrotask(()=>{\n            orama[kRemovals] = undefined;\n        });\n        orama[kRemovals] = 0;\n    }\n    if (orama[kRemovals] > 1000) {\n        warn(\"Orama's remove operation is synchronous. Please avoid removing a large number of document in a single operation in order not to block the main thread, in alternative, please use updateMultiple.\", {\n            code: 'ORAMA0002'\n        });\n        orama[kRemovals] = -1;\n    } else if (orama[kRemovals] >= 0) {\n        orama[kRemovals]++;\n    }\n}\n\n//# sourceMappingURL=sync-blocking-checker.js.map","export const STEMMERS = {\n    arabic: 'ar',\n    armenian: 'am',\n    bulgarian: 'bg',\n    danish: 'dk',\n    dutch: 'nl',\n    english: 'en',\n    finnish: 'fi',\n    french: 'fr',\n    german: 'de',\n    greek: 'gr',\n    hungarian: 'hu',\n    indian: 'in',\n    indonesian: 'id',\n    irish: 'ie',\n    italian: 'it',\n    lithuanian: 'lt',\n    nepali: 'np',\n    norwegian: 'no',\n    portuguese: 'pt',\n    romanian: 'ro',\n    russian: 'ru',\n    serbian: 'rs',\n    slovenian: 'ru',\n    spanish: 'es',\n    swedish: 'se',\n    tamil: 'ta',\n    turkish: 'tr',\n    ukrainian: 'uk',\n    sanskrit: 'sk'\n};\nexport const SPLITTERS = {\n    dutch: /[^A-Za-zàèéìòóù0-9_'-]+/gim,\n    english: /[^A-Za-zàèéìòóù0-9_'-]+/gim,\n    french: /[^a-z0-9äâàéèëêïîöôùüûœç-]+/gim,\n    italian: /[^A-Za-zàèéìòóù0-9_'-]+/gim,\n    norwegian: /[^a-z0-9_æøåÆØÅäÄöÖüÜ]+/gim,\n    portuguese: /[^a-z0-9à-úÀ-Ú]/gim,\n    russian: /[^a-z0-9а-яА-ЯёЁ]+/gim,\n    spanish: /[^a-z0-9A-Zá-úÁ-ÚñÑüÜ]+/gim,\n    swedish: /[^a-z0-9_åÅäÄöÖüÜ-]+/gim,\n    german: /[^a-z0-9A-ZäöüÄÖÜß]+/gim,\n    finnish: /[^a-z0-9äöÄÖ]+/gim,\n    danish: /[^a-z0-9æøåÆØÅ]+/gim,\n    hungarian: /[^a-z0-9áéíóöőúüűÁÉÍÓÖŐÚÜŰ]+/gim,\n    romanian: /[^a-z0-9ăâîșțĂÂÎȘȚ]+/gim,\n    serbian: /[^a-z0-9čćžšđČĆŽŠĐ]+/gim,\n    turkish: /[^a-z0-9çÇğĞıİöÖşŞüÜ]+/gim,\n    lithuanian: /[^a-z0-9ąčęėįšųūžĄČĘĖĮŠŲŪŽ]+/gim,\n    arabic: /[^a-z0-9أ-ي]+/gim,\n    nepali: /[^a-z0-9अ-ह]+/gim,\n    irish: /[^a-z0-9áéíóúÁÉÍÓÚ]+/gim,\n    indian: /[^a-z0-9अ-ह]+/gim,\n    armenian: /[^a-z0-9ա-ֆ]+/gim,\n    greek: /[^a-z0-9α-ωά-ώ]+/gim,\n    indonesian: /[^a-z0-9]+/gim,\n    ukrainian: /[^a-z0-9а-яА-ЯіїєІЇЄ]+/gim,\n    slovenian: /[^a-z0-9čžšČŽŠ]+/gim,\n    bulgarian: /[^a-z0-9а-яА-Я]+/gim,\n    tamil: /[^a-z0-9அ-ஹ]+/gim,\n    sanskrit: /[^a-z0-9A-Zāīūṛḷṃṁḥśṣṭḍṇṅñḻḹṝ]+/gim\n};\nexport const SUPPORTED_LANGUAGES = Object.keys(STEMMERS);\n\n//# sourceMappingURL=languages.js.map","import { SUPPORTED_LANGUAGES } from './components/tokenizer/languages.js';\nimport { sprintf } from './utils.js';\nconst allLanguages = SUPPORTED_LANGUAGES.join('\\n - ');\nconst errors = {\n    NO_LANGUAGE_WITH_CUSTOM_TOKENIZER: 'Do not pass the language option to create when using a custom tokenizer.',\n    LANGUAGE_NOT_SUPPORTED: `Language \"%s\" is not supported.\\nSupported languages are:\\n - ${allLanguages}`,\n    INVALID_STEMMER_FUNCTION_TYPE: `config.stemmer property must be a function.`,\n    MISSING_STEMMER: `As of version 1.0.0 @orama/orama does not ship non English stemmers by default. To solve this, please explicitly import and specify the \"%s\" stemmer from the package @orama/stemmers. See https://docs.oramasearch.com/open-source/text-analysis/stemming for more information.`,\n    CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY: 'Custom stop words array must only contain strings.',\n    UNSUPPORTED_COMPONENT: `Unsupported component \"%s\".`,\n    COMPONENT_MUST_BE_FUNCTION: `The component \"%s\" must be a function.`,\n    COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS: `The component \"%s\" must be a function or an array of functions.`,\n    INVALID_SCHEMA_TYPE: `Unsupported schema type \"%s\" at \"%s\". Expected \"string\", \"boolean\" or \"number\" or array of them.`,\n    DOCUMENT_ID_MUST_BE_STRING: `Document id must be of type \"string\". Got \"%s\" instead.`,\n    DOCUMENT_ALREADY_EXISTS: `A document with id \"%s\" already exists.`,\n    DOCUMENT_DOES_NOT_EXIST: `A document with id \"%s\" does not exists.`,\n    MISSING_DOCUMENT_PROPERTY: `Missing searchable property \"%s\".`,\n    INVALID_DOCUMENT_PROPERTY: `Invalid document property \"%s\": expected \"%s\", got \"%s\"`,\n    UNKNOWN_INDEX: `Invalid property name \"%s\". Expected a wildcard string (\"*\") or array containing one of the following properties: %s`,\n    INVALID_BOOST_VALUE: `Boost value must be a number greater than, or less than 0.`,\n    INVALID_FILTER_OPERATION: `You can only use one operation per filter, you requested %d.`,\n    SCHEMA_VALIDATION_FAILURE: `Cannot insert document due schema validation failure on \"%s\" property.`,\n    INVALID_SORT_SCHEMA_TYPE: `Unsupported sort schema type \"%s\" at \"%s\". Expected \"string\" or \"number\".`,\n    CANNOT_SORT_BY_ARRAY: `Cannot configure sort for \"%s\" because it is an array (%s).`,\n    UNABLE_TO_SORT_ON_UNKNOWN_FIELD: `Unable to sort on unknown field \"%s\". Allowed fields: %s`,\n    SORT_DISABLED: `Sort is disabled. Please read the documentation at https://docs.oramasearch for more information.`,\n    UNKNOWN_GROUP_BY_PROPERTY: `Unknown groupBy property \"%s\".`,\n    INVALID_GROUP_BY_PROPERTY: `Invalid groupBy property \"%s\". Allowed types: \"%s\", but given \"%s\".`,\n    UNKNOWN_FILTER_PROPERTY: `Unknown filter property \"%s\".`,\n    INVALID_VECTOR_SIZE: `Vector size must be a number greater than 0. Got \"%s\" instead.`,\n    INVALID_VECTOR_VALUE: `Vector value must be a number greater than 0. Got \"%s\" instead.`,\n    INVALID_INPUT_VECTOR: `Property \"%s\" was declared as a %s-dimensional vector, but got a %s-dimensional vector instead.\\nInput vectors must be of the size declared in the schema, as calculating similarity between vectors of different sizes can lead to unexpected results.`,\n    WRONG_SEARCH_PROPERTY_TYPE: `Property \"%s\" is not searchable. Only \"string\" properties are searchable.`,\n    FACET_NOT_SUPPORTED: `Facet doens't support the type \"%s\".`,\n    INVALID_DISTANCE_SUFFIX: `Invalid distance suffix \"%s\". Valid suffixes are: cm, m, km, mi, yd, ft.`,\n    INVALID_SEARCH_MODE: `Invalid search mode \"%s\". Valid modes are: \"fulltext\", \"vector\", \"hybrid\".`,\n    MISSING_VECTOR_AND_SECURE_PROXY: `No vector was provided and no secure proxy was configured. Please provide a vector or configure an Orama Secure Proxy to perform hybrid search.`,\n    MISSING_TERM: `\"term\" is a required parameter when performing hybrid search. Please provide a search term.`,\n    INVALID_VECTOR_INPUT: `Invalid \"vector\" property. Expected an object with \"value\" and \"property\" properties, but got \"%s\" instead.`,\n    PLUGIN_CRASHED: `A plugin crashed during initialization. Please check the error message for more information:`\n};\nexport function createError(code, ...args) {\n    const error = new Error(sprintf(errors[code] ?? `Unsupported Orama Error code: ${code}`, ...args));\n    error.code = code;\n    if ('captureStackTrace' in Error.prototype) {\n        Error.captureStackTrace(error);\n    }\n    return error;\n}\n\n//# sourceMappingURL=errors.js.map","import { isArrayType, isGeoPointType, isVectorType } from '../components.js';\nimport { runMultipleHook, runSingleHook } from '../components/hooks.js';\nimport { trackInsertion } from '../components/sync-blocking-checker.js';\nimport { createError } from '../errors.js';\nexport async function insert(orama, doc, language, skipHooks) {\n    const errorProperty = await orama.validateSchema(doc, orama.schema);\n    if (errorProperty) {\n        throw createError('SCHEMA_VALIDATION_FAILURE', errorProperty);\n    }\n    return innerInsert(orama, doc, language, skipHooks);\n}\nasync function innerInsert(orama, doc, language, skipHooks) {\n    const { index , docs  } = orama.data;\n    const id = await orama.getDocumentIndexId(doc);\n    if (typeof id !== 'string') {\n        throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof id);\n    }\n    if (!await orama.documentsStore.store(docs, id, doc)) {\n        throw createError('DOCUMENT_ALREADY_EXISTS', id);\n    }\n    const docsCount = await orama.documentsStore.count(docs);\n    if (!skipHooks) {\n        await runSingleHook(orama.beforeInsert, orama, id, doc);\n    }\n    const indexableProperties = await orama.index.getSearchableProperties(index);\n    const indexablePropertiesWithTypes = await orama.index.getSearchablePropertiesWithTypes(index);\n    const indexableValues = await orama.getDocumentProperties(doc, indexableProperties);\n    for (const [key, value] of Object.entries(indexableValues)){\n        if (typeof value === 'undefined') {\n            continue;\n        }\n        const actualType = typeof value;\n        const expectedType = indexablePropertiesWithTypes[key];\n        if (isGeoPointType(expectedType) && typeof value === 'object' && typeof value.lon === 'number' && typeof value.lat === 'number') {\n            continue;\n        }\n        if (isVectorType(expectedType) && Array.isArray(value)) {\n            continue;\n        }\n        if (isArrayType(expectedType) && Array.isArray(value)) {\n            continue;\n        }\n        if ((expectedType === 'enum' || expectedType === 'enum[]') && (actualType === 'string' || actualType === 'number')) {\n            continue;\n        }\n        if (actualType !== expectedType) {\n            throw createError('INVALID_DOCUMENT_PROPERTY', key, expectedType, actualType);\n        }\n    }\n    for (const prop of indexableProperties){\n        var _orama_index, _orama_index_beforeInsert, _orama_index1, _orama_index_afterInsert;\n        const value = indexableValues[prop];\n        if (typeof value === 'undefined') {\n            continue;\n        }\n        const expectedType = indexablePropertiesWithTypes[prop];\n        await ((_orama_index_beforeInsert = (_orama_index = orama.index).beforeInsert) === null || _orama_index_beforeInsert === void 0 ? void 0 : _orama_index_beforeInsert.call(_orama_index, orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount));\n        await orama.index.insert(orama.index, orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount);\n        await ((_orama_index_afterInsert = (_orama_index1 = orama.index).afterInsert) === null || _orama_index_afterInsert === void 0 ? void 0 : _orama_index_afterInsert.call(_orama_index1, orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount));\n    }\n    const sortableProperties = await orama.sorter.getSortableProperties(orama.data.sorting);\n    const sortablePropertiesWithTypes = await orama.sorter.getSortablePropertiesWithTypes(orama.data.sorting);\n    const sortableValues = await orama.getDocumentProperties(doc, sortableProperties);\n    for (const prop of sortableProperties){\n        const value = sortableValues[prop];\n        if (typeof value === 'undefined') {\n            continue;\n        }\n        const expectedType = sortablePropertiesWithTypes[prop];\n        await orama.sorter.insert(orama.data.sorting, prop, id, value, expectedType, language);\n    }\n    if (!skipHooks) {\n        await runSingleHook(orama.afterInsert, orama, id, doc);\n    }\n    trackInsertion(orama);\n    return id;\n}\nexport async function insertMultiple(orama, docs, batchSize, language, skipHooks, timeout) {\n    if (!skipHooks) {\n        await runMultipleHook(orama.beforeInsertMultiple, orama, docs);\n    }\n    // Validate all documents before the insertion\n    const docsLength = docs.length;\n    for(let i = 0; i < docsLength; i++){\n        const errorProperty = await orama.validateSchema(docs[i], orama.schema);\n        if (errorProperty) {\n            throw createError('SCHEMA_VALIDATION_FAILURE', errorProperty);\n        }\n    }\n    return innerInsertMultiple(orama, docs, batchSize, language, skipHooks, timeout);\n}\nexport async function innerInsertMultiple(orama, docs, batchSize, language, skipHooks, timeout) {\n    if (!batchSize) {\n        batchSize = 1000;\n    }\n    timeout = timeout || 0;\n    const ids = [];\n    await new Promise((resolve, reject)=>{\n        let i = 0;\n        async function _insertMultiple() {\n            const batch = docs.slice(i * batchSize, (i + 1) * batchSize);\n            i++;\n            if (!batch.length) {\n                return resolve();\n            }\n            for (const doc of batch){\n                try {\n                    const id = await insert(orama, doc, language, skipHooks);\n                    ids.push(id);\n                } catch (err) {\n                    reject(err);\n                }\n            }\n            setTimeout(_insertMultiple, timeout);\n        }\n        setTimeout(_insertMultiple, timeout);\n    });\n    if (!skipHooks) {\n        await runMultipleHook(orama.afterInsertMultiple, orama, docs);\n    }\n    return ids;\n}\n\n//# sourceMappingURL=insert.js.map","import { createError } from './errors.js';\nconst baseId = Date.now().toString().slice(5);\nlet lastId = 0;\nconst k = 1024;\nconst nano = BigInt(1e3);\nconst milli = BigInt(1e6);\nconst second = BigInt(1e9);\nexport const isServer = typeof window === 'undefined';\n/**\n * This value can be increased up to 100_000\n * But i don't know if this value change from nodejs to nodejs\n * So I will keep a safer value here.\n */ export const MAX_ARGUMENT_FOR_STACK = 65535;\n/**\n * This method is needed to used because of issues like: https://github.com/oramasearch/orama/issues/301\n * that issue is caused because the array that is pushed is huge (>100k)\n *\n * @example\n * ```ts\n * safeArrayPush(myArray, [1, 2])\n * ```\n */ export function safeArrayPush(arr, newArr) {\n    if (newArr.length < MAX_ARGUMENT_FOR_STACK) {\n        Array.prototype.push.apply(arr, newArr);\n    } else {\n        for(let i = 0; i < newArr.length; i += MAX_ARGUMENT_FOR_STACK){\n            Array.prototype.push.apply(arr, newArr.slice(i, i + MAX_ARGUMENT_FOR_STACK));\n        }\n    }\n}\nexport function sprintf(template, ...args) {\n    return template.replace(/%(?:(?<position>\\d+)\\$)?(?<width>-?\\d*\\.?\\d*)(?<type>[dfs])/g, function(...replaceArgs) {\n        const groups = replaceArgs[replaceArgs.length - 1];\n        const { width: rawWidth , type , position  } = groups;\n        const replacement = position ? args[Number.parseInt(position) - 1] : args.shift();\n        const width = rawWidth === '' ? 0 : Number.parseInt(rawWidth);\n        switch(type){\n            case 'd':\n                return replacement.toString().padStart(width, '0');\n            case 'f':\n                {\n                    let value = replacement;\n                    const [padding, precision] = rawWidth.split('.').map((w)=>Number.parseFloat(w));\n                    if (typeof precision === 'number' && precision >= 0) {\n                        value = value.toFixed(precision);\n                    }\n                    return typeof padding === 'number' && padding >= 0 ? value.toString().padStart(width, '0') : value.toString();\n                }\n            case 's':\n                return width < 0 ? replacement.toString().padEnd(-width, ' ') : replacement.toString().padStart(width, ' ');\n            default:\n                return replacement;\n        }\n    });\n}\nexport async function formatBytes(bytes, decimals = 2) {\n    if (bytes === 0) {\n        return '0 Bytes';\n    }\n    const dm = decimals < 0 ? 0 : decimals;\n    const sizes = [\n        'Bytes',\n        'KB',\n        'MB',\n        'GB',\n        'TB',\n        'PB',\n        'EB',\n        'ZB',\n        'YB'\n    ];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;\n}\nexport function isInsideWebWorker() {\n    // @ts-expect-error - WebWorker global scope\n    return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n}\nexport function isInsideNode() {\n    return typeof process !== 'undefined' && process.release && process.release.name === 'node';\n}\nexport function getNanosecondTimeViaPerformance() {\n    return BigInt(Math.floor(performance.now() * 1e6));\n}\nexport async function formatNanoseconds(value) {\n    if (typeof value === 'number') {\n        value = BigInt(value);\n    }\n    if (value < nano) {\n        return `${value}ns`;\n    } else if (value < milli) {\n        return `${value / nano}μs`;\n    } else if (value < second) {\n        return `${value / milli}ms`;\n    }\n    return `${value / second}s`;\n}\nexport async function getNanosecondsTime() {\n    if (isInsideWebWorker()) {\n        return getNanosecondTimeViaPerformance();\n    }\n    if (isInsideNode()) {\n        return process.hrtime.bigint();\n    }\n    if (typeof process !== 'undefined' && process.hrtime !== undefined) {\n        return process.hrtime.bigint();\n    }\n    if (typeof performance !== 'undefined') {\n        return getNanosecondTimeViaPerformance();\n    }\n    // @todo: fallback to V8 native method to get microtime\n    return BigInt(0);\n}\nexport async function uniqueId() {\n    return `${baseId}-${lastId++}`;\n}\nexport function getOwnProperty(object, property) {\n    // Checks if `hasOwn` method is defined avoiding errors with older Node.js versions\n    if (Object.hasOwn === undefined) {\n        return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;\n    }\n    return Object.hasOwn(object, property) ? object[property] : undefined;\n}\nexport function getTokenFrequency(token, tokens) {\n    let count = 0;\n    for (const t of tokens){\n        if (t === token) {\n            count++;\n        }\n    }\n    return count;\n}\nexport function insertSortedValue(arr, el, compareFn = sortTokenScorePredicate) {\n    let low = 0;\n    let high = arr.length;\n    let mid;\n    while(low < high){\n        mid = low + high >>> 1;\n        if (compareFn(el, arr[mid]) < 0) {\n            high = mid;\n        } else {\n            low = mid + 1;\n        }\n    }\n    arr.splice(low, 0, el);\n    return arr;\n}\nexport function sortTokenScorePredicate(a, b) {\n    if (b[1] === a[1]) {\n        return a[0] - b[0];\n    }\n    return b[1] - a[1];\n}\n// Intersection function taken from https://github.com/lovasoa/fast_array_intersect.\n// MIT Licensed at the time of writing.\nexport function intersect(arrays) {\n    if (arrays.length === 0) {\n        return [];\n    } else if (arrays.length === 1) {\n        return arrays[0];\n    }\n    for(let i = 1; i < arrays.length; i++){\n        if (arrays[i].length < arrays[0].length) {\n            const tmp = arrays[0];\n            arrays[0] = arrays[i];\n            arrays[i] = tmp;\n        }\n    }\n    const set = new Map();\n    for (const elem of arrays[0]){\n        set.set(elem, 1);\n    }\n    for(let i = 1; i < arrays.length; i++){\n        let found = 0;\n        for (const elem of arrays[i]){\n            const count = set.get(elem);\n            if (count === i) {\n                set.set(elem, count + 1);\n                found++;\n            }\n        }\n        if (found === 0) return [];\n    }\n    return arrays[0].filter((e)=>{\n        const count = set.get(e);\n        if (count !== undefined) set.set(e, 0);\n        return count === arrays.length;\n    });\n}\nexport async function getDocumentProperties(doc, paths) {\n    const properties = {};\n    const pathsLength = paths.length;\n    for(let i = 0; i < pathsLength; i++){\n        const path = paths[i];\n        const pathTokens = path.split('.');\n        let current = doc;\n        const pathTokensLength = pathTokens.length;\n        for(let j = 0; j < pathTokensLength; j++){\n            current = current[pathTokens[j]];\n            // We found an object but we were supposed to be done\n            if (typeof current === 'object') {\n                if (current !== null && 'lat' in current && 'lon' in current && typeof current.lat === 'number' && typeof current.lon === 'number') {\n                    current = properties[path] = current;\n                    break;\n                } else if (!Array.isArray(current) && current !== null && j === pathTokensLength - 1) {\n                    current = undefined;\n                    break;\n                }\n            } else if ((current === null || typeof current !== 'object') && j < pathTokensLength - 1) {\n                // We can't recurse anymore but we were supposed to\n                current = undefined;\n                break;\n            }\n        }\n        if (typeof current !== 'undefined') {\n            properties[path] = current;\n        }\n    }\n    return properties;\n}\nexport async function getNested(obj, path) {\n    const props = await getDocumentProperties(obj, [\n        path\n    ]);\n    return props[path];\n}\nexport function flattenObject(obj, prefix = '') {\n    const result = {};\n    for(const key in obj){\n        const prop = `${prefix}${key}`;\n        const objKey = obj[key];\n        if (typeof objKey === 'object' && objKey !== null) {\n            Object.assign(result, flattenObject(objKey, `${prop}.`));\n        } else {\n            result[prop] = objKey;\n        }\n    }\n    return result;\n}\nconst mapDistanceToMeters = {\n    cm: 0.01,\n    m: 1,\n    km: 1000,\n    ft: 0.3048,\n    yd: 0.9144,\n    mi: 1609.344\n};\nexport function convertDistanceToMeters(distance, unit) {\n    const ratio = mapDistanceToMeters[unit];\n    if (ratio === undefined) {\n        throw new Error(createError('INVALID_DISTANCE_SUFFIX', distance).message);\n    }\n    return distance * ratio;\n}\nexport function removeVectorsFromHits(searchResult, vectorProperties) {\n    searchResult.hits = searchResult.hits.map((result)=>({\n            ...result,\n            document: {\n                ...result.document,\n                // Remove embeddings from the result\n                ...vectorProperties.reduce((acc, prop)=>{\n                    const path = prop.split('.');\n                    const lastKey = path.pop();\n                    let obj = acc;\n                    for (const key of path){\n                        obj[key] = obj[key] ?? {};\n                        obj = obj[key];\n                    }\n                    obj[lastKey] = null;\n                    return acc;\n                }, result.document)\n            }\n        }));\n}\n\n//# sourceMappingURL=utils.js.map"],"names":["async","formatElapsedTime","n","raw","Number","formatted","getDocumentIndexId","doc","id","validateSchema","schema","prop","type","Object","entries","value","lon","lat","Array","isArray","valueLength","length","i","isVectorType","vectorSize","getVectorSize","isArrayType","expectedType","getInnerType","subProp","IS_ARRAY_TYPE","string","number","boolean","enum","geopoint","INNER_TYPE","isGeoPointType","test","size","slice","isNaN","OBJECT_COMPONENTS","FUNCTION_COMPONENTS","runSingleHook","hooks","orama","hooksLength","runMultipleHook","docsOrIds","runAfterSearch","db","params","language","results","runBeforeSearch","kInsertions","Symbol","kRemovals","_globalThis_process","warn","globalThis","process","emitWarning","message","options","console","code","trackInsertion","queueMicrotask","undefined","trackRemoval","SPLITTERS","dutch","english","french","italian","norwegian","portuguese","russian","spanish","swedish","german","finnish","danish","hungarian","romanian","serbian","turkish","lithuanian","arabic","nepali","irish","indian","armenian","greek","indonesian","ukrainian","slovenian","bulgarian","tamil","sanskrit","SUPPORTED_LANGUAGES","keys","errors","NO_LANGUAGE_WITH_CUSTOM_TOKENIZER","LANGUAGE_NOT_SUPPORTED","join","INVALID_STEMMER_FUNCTION_TYPE","MISSING_STEMMER","CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY","UNSUPPORTED_COMPONENT","COMPONENT_MUST_BE_FUNCTION","COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS","INVALID_SCHEMA_TYPE","DOCUMENT_ID_MUST_BE_STRING","DOCUMENT_ALREADY_EXISTS","DOCUMENT_DOES_NOT_EXIST","MISSING_DOCUMENT_PROPERTY","INVALID_DOCUMENT_PROPERTY","UNKNOWN_INDEX","INVALID_BOOST_VALUE","INVALID_FILTER_OPERATION","SCHEMA_VALIDATION_FAILURE","INVALID_SORT_SCHEMA_TYPE","CANNOT_SORT_BY_ARRAY","UNABLE_TO_SORT_ON_UNKNOWN_FIELD","SORT_DISABLED","UNKNOWN_GROUP_BY_PROPERTY","INVALID_GROUP_BY_PROPERTY","UNKNOWN_FILTER_PROPERTY","INVALID_VECTOR_SIZE","INVALID_VECTOR_VALUE","INVALID_INPUT_VECTOR","WRONG_SEARCH_PROPERTY_TYPE","FACET_NOT_SUPPORTED","INVALID_DISTANCE_SUFFIX","INVALID_SEARCH_MODE","MISSING_VECTOR_AND_SECURE_PROXY","MISSING_TERM","INVALID_VECTOR_INPUT","PLUGIN_CRASHED","createError","args","error","Error","prototype","captureStackTrace","insert","skipHooks","errorProperty","index","docs","data","documentsStore","store","docsCount","count","beforeInsert","indexableProperties","getSearchableProperties","indexablePropertiesWithTypes","getSearchablePropertiesWithTypes","indexableValues","getDocumentProperties","key","actualType","_orama_index","_orama_index_beforeInsert","_orama_index1","_orama_index_afterInsert","call","tokenizer","afterInsert","sortableProperties","sorter","getSortableProperties","sorting","sortablePropertiesWithTypes","getSortablePropertiesWithTypes","sortableValues","innerInsert","insertMultiple","batchSize","timeout","beforeInsertMultiple","docsLength","innerInsertMultiple","ids","Promise","resolve","reject","setTimeout","_insertMultiple","batch","push","err","afterInsertMultiple","baseId","Date","now","toString","lastId","k","nano","BigInt","milli","second","MAX_ARGUMENT_FOR_STACK","safeArrayPush","arr","newArr","apply","sprintf","template","replace","replaceArgs","groups","width","rawWidth","position","replacement","parseInt","shift","padStart","padding","precision","split","map","w","parseFloat","toFixed","padEnd","formatBytes","bytes","decimals","dm","Math","floor","log","pow","getNanosecondTimeViaPerformance","performance","formatNanoseconds","getNanosecondsTime","WorkerGlobalScope","self","release","name","hrtime","bigint","uniqueId","getOwnProperty","object","property","hasOwn","hasOwnProperty","sortTokenScorePredicate","a","b","intersect","arrays","tmp","set","Map","elem","found","get","filter","e","paths","properties","pathsLength","path","pathTokens","current","pathTokensLength","j","getNested","obj","mapDistanceToMeters","cm","m","km","ft","yd","mi","convertDistanceToMeters","distance","unit","ratio","removeVectorsFromHits","searchResult","vectorProperties","hits","result","document","reduce","acc","lastKey","pop"],"sourceRoot":""}