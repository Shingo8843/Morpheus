{"version":3,"file":"862.index.js","mappings":"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","sources":["webpack://morpheus/./node_modules/@orama/orama/dist/components/defaults.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/tokenizer/languages.js","webpack://morpheus/./node_modules/@orama/orama/dist/errors.js","webpack://morpheus/./node_modules/@orama/orama/dist/utils.js"],"sourcesContent":["import { createError } from '../errors.js';\nimport { formatNanoseconds, uniqueId } from '../utils.js';\nexport { getDocumentProperties } from '../utils.js';\nexport async function formatElapsedTime(n) {\n    return {\n        raw: Number(n),\n        formatted: await formatNanoseconds(n)\n    };\n}\nexport async function getDocumentIndexId(doc) {\n    if (doc.id) {\n        if (typeof doc.id !== 'string') {\n            throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof doc.id);\n        }\n        return doc.id;\n    }\n    return await uniqueId();\n}\nexport async function validateSchema(doc, schema) {\n    for (const [prop, type] of Object.entries(schema)){\n        const value = doc[prop];\n        if (typeof value === 'undefined') {\n            continue;\n        }\n        if (type === 'geopoint' && typeof value === 'object' && typeof value.lon === 'number' && typeof value.lat === 'number') {\n            continue;\n        }\n        if (type === 'enum' && (typeof value === 'string' || typeof value === 'number')) {\n            continue;\n        }\n        if (type === 'enum[]' && Array.isArray(value)) {\n            const valueLength = value.length;\n            for(let i = 0; i < valueLength; i++){\n                if (typeof value[i] !== 'string' && typeof value[i] !== 'number') {\n                    return prop + '.' + i;\n                }\n            }\n            continue;\n        }\n        if (isVectorType(type)) {\n            const vectorSize = getVectorSize(type);\n            if (!Array.isArray(value) || value.length !== vectorSize) {\n                throw createError('INVALID_INPUT_VECTOR', prop, vectorSize, value.length);\n            }\n            continue;\n        }\n        if (isArrayType(type)) {\n            if (!Array.isArray(value)) {\n                return prop;\n            }\n            const expectedType = getInnerType(type);\n            const valueLength = value.length;\n            for(let i = 0; i < valueLength; i++){\n                if (typeof value[i] !== expectedType) {\n                    return prop + '.' + i;\n                }\n            }\n            continue;\n        }\n        if (typeof type === 'object') {\n            if (!value || typeof value !== 'object') {\n                return prop;\n            }\n            // using as ResultDocument is not exactly right but trying to be type-safe here is not useful\n            const subProp = await validateSchema(value, type);\n            if (subProp) {\n                return prop + '.' + subProp;\n            }\n            continue;\n        }\n        if (typeof value !== type) {\n            return prop;\n        }\n    }\n    return undefined;\n}\nconst IS_ARRAY_TYPE = {\n    string: false,\n    number: false,\n    boolean: false,\n    enum: false,\n    geopoint: false,\n    'string[]': true,\n    'number[]': true,\n    'boolean[]': true,\n    'enum[]': true\n};\nconst INNER_TYPE = {\n    'string[]': 'string',\n    'number[]': 'number',\n    'boolean[]': 'boolean',\n    'enum[]': 'enum'\n};\nexport function isGeoPointType(type) {\n    return type === 'geopoint';\n}\nexport function isVectorType(type) {\n    return typeof type === 'string' && /^vector\\[\\d+\\]$/.test(type);\n}\nexport function isArrayType(type) {\n    return typeof type === 'string' && IS_ARRAY_TYPE[type];\n}\nexport function getInnerType(type) {\n    return INNER_TYPE[type];\n}\nexport function getVectorSize(type) {\n    const size = Number(type.slice(7, -1));\n    switch(true){\n        case isNaN(size):\n            throw createError('INVALID_VECTOR_VALUE', type);\n        case size <= 0:\n            throw createError('INVALID_VECTOR_SIZE', type);\n        default:\n            return size;\n    }\n}\n\n//# sourceMappingURL=defaults.js.map","export const STEMMERS = {\n    arabic: 'ar',\n    armenian: 'am',\n    bulgarian: 'bg',\n    danish: 'dk',\n    dutch: 'nl',\n    english: 'en',\n    finnish: 'fi',\n    french: 'fr',\n    german: 'de',\n    greek: 'gr',\n    hungarian: 'hu',\n    indian: 'in',\n    indonesian: 'id',\n    irish: 'ie',\n    italian: 'it',\n    lithuanian: 'lt',\n    nepali: 'np',\n    norwegian: 'no',\n    portuguese: 'pt',\n    romanian: 'ro',\n    russian: 'ru',\n    serbian: 'rs',\n    slovenian: 'ru',\n    spanish: 'es',\n    swedish: 'se',\n    tamil: 'ta',\n    turkish: 'tr',\n    ukrainian: 'uk',\n    sanskrit: 'sk'\n};\nexport const SPLITTERS = {\n    dutch: /[^A-Za-zàèéìòóù0-9_'-]+/gim,\n    english: /[^A-Za-zàèéìòóù0-9_'-]+/gim,\n    french: /[^a-z0-9äâàéèëêïîöôùüûœç-]+/gim,\n    italian: /[^A-Za-zàèéìòóù0-9_'-]+/gim,\n    norwegian: /[^a-z0-9_æøåÆØÅäÄöÖüÜ]+/gim,\n    portuguese: /[^a-z0-9à-úÀ-Ú]/gim,\n    russian: /[^a-z0-9а-яА-ЯёЁ]+/gim,\n    spanish: /[^a-z0-9A-Zá-úÁ-ÚñÑüÜ]+/gim,\n    swedish: /[^a-z0-9_åÅäÄöÖüÜ-]+/gim,\n    german: /[^a-z0-9A-ZäöüÄÖÜß]+/gim,\n    finnish: /[^a-z0-9äöÄÖ]+/gim,\n    danish: /[^a-z0-9æøåÆØÅ]+/gim,\n    hungarian: /[^a-z0-9áéíóöőúüűÁÉÍÓÖŐÚÜŰ]+/gim,\n    romanian: /[^a-z0-9ăâîșțĂÂÎȘȚ]+/gim,\n    serbian: /[^a-z0-9čćžšđČĆŽŠĐ]+/gim,\n    turkish: /[^a-z0-9çÇğĞıİöÖşŞüÜ]+/gim,\n    lithuanian: /[^a-z0-9ąčęėįšųūžĄČĘĖĮŠŲŪŽ]+/gim,\n    arabic: /[^a-z0-9أ-ي]+/gim,\n    nepali: /[^a-z0-9अ-ह]+/gim,\n    irish: /[^a-z0-9áéíóúÁÉÍÓÚ]+/gim,\n    indian: /[^a-z0-9अ-ह]+/gim,\n    armenian: /[^a-z0-9ա-ֆ]+/gim,\n    greek: /[^a-z0-9α-ωά-ώ]+/gim,\n    indonesian: /[^a-z0-9]+/gim,\n    ukrainian: /[^a-z0-9а-яА-ЯіїєІЇЄ]+/gim,\n    slovenian: /[^a-z0-9čžšČŽŠ]+/gim,\n    bulgarian: /[^a-z0-9а-яА-Я]+/gim,\n    tamil: /[^a-z0-9அ-ஹ]+/gim,\n    sanskrit: /[^a-z0-9A-Zāīūṛḷṃṁḥśṣṭḍṇṅñḻḹṝ]+/gim\n};\nexport const SUPPORTED_LANGUAGES = Object.keys(STEMMERS);\n\n//# sourceMappingURL=languages.js.map","import { SUPPORTED_LANGUAGES } from './components/tokenizer/languages.js';\nimport { sprintf } from './utils.js';\nconst allLanguages = SUPPORTED_LANGUAGES.join('\\n - ');\nconst errors = {\n    NO_LANGUAGE_WITH_CUSTOM_TOKENIZER: 'Do not pass the language option to create when using a custom tokenizer.',\n    LANGUAGE_NOT_SUPPORTED: `Language \"%s\" is not supported.\\nSupported languages are:\\n - ${allLanguages}`,\n    INVALID_STEMMER_FUNCTION_TYPE: `config.stemmer property must be a function.`,\n    MISSING_STEMMER: `As of version 1.0.0 @orama/orama does not ship non English stemmers by default. To solve this, please explicitly import and specify the \"%s\" stemmer from the package @orama/stemmers. See https://docs.oramasearch.com/open-source/text-analysis/stemming for more information.`,\n    CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY: 'Custom stop words array must only contain strings.',\n    UNSUPPORTED_COMPONENT: `Unsupported component \"%s\".`,\n    COMPONENT_MUST_BE_FUNCTION: `The component \"%s\" must be a function.`,\n    COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS: `The component \"%s\" must be a function or an array of functions.`,\n    INVALID_SCHEMA_TYPE: `Unsupported schema type \"%s\" at \"%s\". Expected \"string\", \"boolean\" or \"number\" or array of them.`,\n    DOCUMENT_ID_MUST_BE_STRING: `Document id must be of type \"string\". Got \"%s\" instead.`,\n    DOCUMENT_ALREADY_EXISTS: `A document with id \"%s\" already exists.`,\n    DOCUMENT_DOES_NOT_EXIST: `A document with id \"%s\" does not exists.`,\n    MISSING_DOCUMENT_PROPERTY: `Missing searchable property \"%s\".`,\n    INVALID_DOCUMENT_PROPERTY: `Invalid document property \"%s\": expected \"%s\", got \"%s\"`,\n    UNKNOWN_INDEX: `Invalid property name \"%s\". Expected a wildcard string (\"*\") or array containing one of the following properties: %s`,\n    INVALID_BOOST_VALUE: `Boost value must be a number greater than, or less than 0.`,\n    INVALID_FILTER_OPERATION: `You can only use one operation per filter, you requested %d.`,\n    SCHEMA_VALIDATION_FAILURE: `Cannot insert document due schema validation failure on \"%s\" property.`,\n    INVALID_SORT_SCHEMA_TYPE: `Unsupported sort schema type \"%s\" at \"%s\". Expected \"string\" or \"number\".`,\n    CANNOT_SORT_BY_ARRAY: `Cannot configure sort for \"%s\" because it is an array (%s).`,\n    UNABLE_TO_SORT_ON_UNKNOWN_FIELD: `Unable to sort on unknown field \"%s\". Allowed fields: %s`,\n    SORT_DISABLED: `Sort is disabled. Please read the documentation at https://docs.oramasearch for more information.`,\n    UNKNOWN_GROUP_BY_PROPERTY: `Unknown groupBy property \"%s\".`,\n    INVALID_GROUP_BY_PROPERTY: `Invalid groupBy property \"%s\". Allowed types: \"%s\", but given \"%s\".`,\n    UNKNOWN_FILTER_PROPERTY: `Unknown filter property \"%s\".`,\n    INVALID_VECTOR_SIZE: `Vector size must be a number greater than 0. Got \"%s\" instead.`,\n    INVALID_VECTOR_VALUE: `Vector value must be a number greater than 0. Got \"%s\" instead.`,\n    INVALID_INPUT_VECTOR: `Property \"%s\" was declared as a %s-dimensional vector, but got a %s-dimensional vector instead.\\nInput vectors must be of the size declared in the schema, as calculating similarity between vectors of different sizes can lead to unexpected results.`,\n    WRONG_SEARCH_PROPERTY_TYPE: `Property \"%s\" is not searchable. Only \"string\" properties are searchable.`,\n    FACET_NOT_SUPPORTED: `Facet doens't support the type \"%s\".`,\n    INVALID_DISTANCE_SUFFIX: `Invalid distance suffix \"%s\". Valid suffixes are: cm, m, km, mi, yd, ft.`,\n    INVALID_SEARCH_MODE: `Invalid search mode \"%s\". Valid modes are: \"fulltext\", \"vector\", \"hybrid\".`,\n    MISSING_VECTOR_AND_SECURE_PROXY: `No vector was provided and no secure proxy was configured. Please provide a vector or configure an Orama Secure Proxy to perform hybrid search.`,\n    MISSING_TERM: `\"term\" is a required parameter when performing hybrid search. Please provide a search term.`,\n    INVALID_VECTOR_INPUT: `Invalid \"vector\" property. Expected an object with \"value\" and \"property\" properties, but got \"%s\" instead.`,\n    PLUGIN_CRASHED: `A plugin crashed during initialization. Please check the error message for more information:`\n};\nexport function createError(code, ...args) {\n    const error = new Error(sprintf(errors[code] ?? `Unsupported Orama Error code: ${code}`, ...args));\n    error.code = code;\n    if ('captureStackTrace' in Error.prototype) {\n        Error.captureStackTrace(error);\n    }\n    return error;\n}\n\n//# sourceMappingURL=errors.js.map","import { createError } from './errors.js';\nconst baseId = Date.now().toString().slice(5);\nlet lastId = 0;\nconst k = 1024;\nconst nano = BigInt(1e3);\nconst milli = BigInt(1e6);\nconst second = BigInt(1e9);\nexport const isServer = typeof window === 'undefined';\n/**\n * This value can be increased up to 100_000\n * But i don't know if this value change from nodejs to nodejs\n * So I will keep a safer value here.\n */ export const MAX_ARGUMENT_FOR_STACK = 65535;\n/**\n * This method is needed to used because of issues like: https://github.com/oramasearch/orama/issues/301\n * that issue is caused because the array that is pushed is huge (>100k)\n *\n * @example\n * ```ts\n * safeArrayPush(myArray, [1, 2])\n * ```\n */ export function safeArrayPush(arr, newArr) {\n    if (newArr.length < MAX_ARGUMENT_FOR_STACK) {\n        Array.prototype.push.apply(arr, newArr);\n    } else {\n        for(let i = 0; i < newArr.length; i += MAX_ARGUMENT_FOR_STACK){\n            Array.prototype.push.apply(arr, newArr.slice(i, i + MAX_ARGUMENT_FOR_STACK));\n        }\n    }\n}\nexport function sprintf(template, ...args) {\n    return template.replace(/%(?:(?<position>\\d+)\\$)?(?<width>-?\\d*\\.?\\d*)(?<type>[dfs])/g, function(...replaceArgs) {\n        const groups = replaceArgs[replaceArgs.length - 1];\n        const { width: rawWidth , type , position  } = groups;\n        const replacement = position ? args[Number.parseInt(position) - 1] : args.shift();\n        const width = rawWidth === '' ? 0 : Number.parseInt(rawWidth);\n        switch(type){\n            case 'd':\n                return replacement.toString().padStart(width, '0');\n            case 'f':\n                {\n                    let value = replacement;\n                    const [padding, precision] = rawWidth.split('.').map((w)=>Number.parseFloat(w));\n                    if (typeof precision === 'number' && precision >= 0) {\n                        value = value.toFixed(precision);\n                    }\n                    return typeof padding === 'number' && padding >= 0 ? value.toString().padStart(width, '0') : value.toString();\n                }\n            case 's':\n                return width < 0 ? replacement.toString().padEnd(-width, ' ') : replacement.toString().padStart(width, ' ');\n            default:\n                return replacement;\n        }\n    });\n}\nexport async function formatBytes(bytes, decimals = 2) {\n    if (bytes === 0) {\n        return '0 Bytes';\n    }\n    const dm = decimals < 0 ? 0 : decimals;\n    const sizes = [\n        'Bytes',\n        'KB',\n        'MB',\n        'GB',\n        'TB',\n        'PB',\n        'EB',\n        'ZB',\n        'YB'\n    ];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;\n}\nexport function isInsideWebWorker() {\n    // @ts-expect-error - WebWorker global scope\n    return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n}\nexport function isInsideNode() {\n    return typeof process !== 'undefined' && process.release && process.release.name === 'node';\n}\nexport function getNanosecondTimeViaPerformance() {\n    return BigInt(Math.floor(performance.now() * 1e6));\n}\nexport async function formatNanoseconds(value) {\n    if (typeof value === 'number') {\n        value = BigInt(value);\n    }\n    if (value < nano) {\n        return `${value}ns`;\n    } else if (value < milli) {\n        return `${value / nano}μs`;\n    } else if (value < second) {\n        return `${value / milli}ms`;\n    }\n    return `${value / second}s`;\n}\nexport async function getNanosecondsTime() {\n    if (isInsideWebWorker()) {\n        return getNanosecondTimeViaPerformance();\n    }\n    if (isInsideNode()) {\n        return process.hrtime.bigint();\n    }\n    if (typeof process !== 'undefined' && process.hrtime !== undefined) {\n        return process.hrtime.bigint();\n    }\n    if (typeof performance !== 'undefined') {\n        return getNanosecondTimeViaPerformance();\n    }\n    // @todo: fallback to V8 native method to get microtime\n    return BigInt(0);\n}\nexport async function uniqueId() {\n    return `${baseId}-${lastId++}`;\n}\nexport function getOwnProperty(object, property) {\n    // Checks if `hasOwn` method is defined avoiding errors with older Node.js versions\n    if (Object.hasOwn === undefined) {\n        return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;\n    }\n    return Object.hasOwn(object, property) ? object[property] : undefined;\n}\nexport function getTokenFrequency(token, tokens) {\n    let count = 0;\n    for (const t of tokens){\n        if (t === token) {\n            count++;\n        }\n    }\n    return count;\n}\nexport function insertSortedValue(arr, el, compareFn = sortTokenScorePredicate) {\n    let low = 0;\n    let high = arr.length;\n    let mid;\n    while(low < high){\n        mid = low + high >>> 1;\n        if (compareFn(el, arr[mid]) < 0) {\n            high = mid;\n        } else {\n            low = mid + 1;\n        }\n    }\n    arr.splice(low, 0, el);\n    return arr;\n}\nexport function sortTokenScorePredicate(a, b) {\n    if (b[1] === a[1]) {\n        return a[0] - b[0];\n    }\n    return b[1] - a[1];\n}\n// Intersection function taken from https://github.com/lovasoa/fast_array_intersect.\n// MIT Licensed at the time of writing.\nexport function intersect(arrays) {\n    if (arrays.length === 0) {\n        return [];\n    } else if (arrays.length === 1) {\n        return arrays[0];\n    }\n    for(let i = 1; i < arrays.length; i++){\n        if (arrays[i].length < arrays[0].length) {\n            const tmp = arrays[0];\n            arrays[0] = arrays[i];\n            arrays[i] = tmp;\n        }\n    }\n    const set = new Map();\n    for (const elem of arrays[0]){\n        set.set(elem, 1);\n    }\n    for(let i = 1; i < arrays.length; i++){\n        let found = 0;\n        for (const elem of arrays[i]){\n            const count = set.get(elem);\n            if (count === i) {\n                set.set(elem, count + 1);\n                found++;\n            }\n        }\n        if (found === 0) return [];\n    }\n    return arrays[0].filter((e)=>{\n        const count = set.get(e);\n        if (count !== undefined) set.set(e, 0);\n        return count === arrays.length;\n    });\n}\nexport async function getDocumentProperties(doc, paths) {\n    const properties = {};\n    const pathsLength = paths.length;\n    for(let i = 0; i < pathsLength; i++){\n        const path = paths[i];\n        const pathTokens = path.split('.');\n        let current = doc;\n        const pathTokensLength = pathTokens.length;\n        for(let j = 0; j < pathTokensLength; j++){\n            current = current[pathTokens[j]];\n            // We found an object but we were supposed to be done\n            if (typeof current === 'object') {\n                if (current !== null && 'lat' in current && 'lon' in current && typeof current.lat === 'number' && typeof current.lon === 'number') {\n                    current = properties[path] = current;\n                    break;\n                } else if (!Array.isArray(current) && current !== null && j === pathTokensLength - 1) {\n                    current = undefined;\n                    break;\n                }\n            } else if ((current === null || typeof current !== 'object') && j < pathTokensLength - 1) {\n                // We can't recurse anymore but we were supposed to\n                current = undefined;\n                break;\n            }\n        }\n        if (typeof current !== 'undefined') {\n            properties[path] = current;\n        }\n    }\n    return properties;\n}\nexport async function getNested(obj, path) {\n    const props = await getDocumentProperties(obj, [\n        path\n    ]);\n    return props[path];\n}\nexport function flattenObject(obj, prefix = '') {\n    const result = {};\n    for(const key in obj){\n        const prop = `${prefix}${key}`;\n        const objKey = obj[key];\n        if (typeof objKey === 'object' && objKey !== null) {\n            Object.assign(result, flattenObject(objKey, `${prop}.`));\n        } else {\n            result[prop] = objKey;\n        }\n    }\n    return result;\n}\nconst mapDistanceToMeters = {\n    cm: 0.01,\n    m: 1,\n    km: 1000,\n    ft: 0.3048,\n    yd: 0.9144,\n    mi: 1609.344\n};\nexport function convertDistanceToMeters(distance, unit) {\n    const ratio = mapDistanceToMeters[unit];\n    if (ratio === undefined) {\n        throw new Error(createError('INVALID_DISTANCE_SUFFIX', distance).message);\n    }\n    return distance * ratio;\n}\nexport function removeVectorsFromHits(searchResult, vectorProperties) {\n    searchResult.hits = searchResult.hits.map((result)=>({\n            ...result,\n            document: {\n                ...result.document,\n                // Remove embeddings from the result\n                ...vectorProperties.reduce((acc, prop)=>{\n                    const path = prop.split('.');\n                    const lastKey = path.pop();\n                    let obj = acc;\n                    for (const key of path){\n                        obj[key] = obj[key] ?? {};\n                        obj = obj[key];\n                    }\n                    obj[lastKey] = null;\n                    return acc;\n                }, result.document)\n            }\n        }));\n}\n\n//# sourceMappingURL=utils.js.map"],"names":["async","formatElapsedTime","n","raw","Number","formatted","getDocumentIndexId","doc","id","validateSchema","schema","prop","type","Object","entries","value","lon","lat","Array","isArray","valueLength","length","i","isVectorType","vectorSize","getVectorSize","isArrayType","expectedType","getInnerType","subProp","IS_ARRAY_TYPE","string","number","boolean","enum","geopoint","INNER_TYPE","isGeoPointType","test","size","slice","isNaN","SPLITTERS","dutch","english","french","italian","norwegian","portuguese","russian","spanish","swedish","german","finnish","danish","hungarian","romanian","serbian","turkish","lithuanian","arabic","nepali","irish","indian","armenian","greek","indonesian","ukrainian","slovenian","bulgarian","tamil","sanskrit","SUPPORTED_LANGUAGES","keys","errors","NO_LANGUAGE_WITH_CUSTOM_TOKENIZER","LANGUAGE_NOT_SUPPORTED","join","INVALID_STEMMER_FUNCTION_TYPE","MISSING_STEMMER","CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY","UNSUPPORTED_COMPONENT","COMPONENT_MUST_BE_FUNCTION","COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS","INVALID_SCHEMA_TYPE","DOCUMENT_ID_MUST_BE_STRING","DOCUMENT_ALREADY_EXISTS","DOCUMENT_DOES_NOT_EXIST","MISSING_DOCUMENT_PROPERTY","INVALID_DOCUMENT_PROPERTY","UNKNOWN_INDEX","INVALID_BOOST_VALUE","INVALID_FILTER_OPERATION","SCHEMA_VALIDATION_FAILURE","INVALID_SORT_SCHEMA_TYPE","CANNOT_SORT_BY_ARRAY","UNABLE_TO_SORT_ON_UNKNOWN_FIELD","SORT_DISABLED","UNKNOWN_GROUP_BY_PROPERTY","INVALID_GROUP_BY_PROPERTY","UNKNOWN_FILTER_PROPERTY","INVALID_VECTOR_SIZE","INVALID_VECTOR_VALUE","INVALID_INPUT_VECTOR","WRONG_SEARCH_PROPERTY_TYPE","FACET_NOT_SUPPORTED","INVALID_DISTANCE_SUFFIX","INVALID_SEARCH_MODE","MISSING_VECTOR_AND_SECURE_PROXY","MISSING_TERM","INVALID_VECTOR_INPUT","PLUGIN_CRASHED","createError","code","args","error","Error","prototype","captureStackTrace","baseId","Date","now","toString","lastId","k","nano","BigInt","milli","second","MAX_ARGUMENT_FOR_STACK","safeArrayPush","arr","newArr","push","apply","sprintf","template","replace","replaceArgs","groups","width","rawWidth","position","replacement","parseInt","shift","padStart","padding","precision","split","map","w","parseFloat","toFixed","padEnd","formatBytes","bytes","decimals","dm","Math","floor","log","pow","getNanosecondTimeViaPerformance","performance","formatNanoseconds","getNanosecondsTime","WorkerGlobalScope","self","process","release","name","undefined","hrtime","bigint","uniqueId","getOwnProperty","object","property","hasOwn","hasOwnProperty","call","sortTokenScorePredicate","a","b","intersect","arrays","tmp","set","Map","elem","found","count","get","filter","e","getDocumentProperties","paths","properties","pathsLength","path","pathTokens","current","pathTokensLength","j","getNested","obj","mapDistanceToMeters","cm","m","km","ft","yd","mi","convertDistanceToMeters","distance","unit","ratio","message","removeVectorsFromHits","searchResult","vectorProperties","hits","result","document","reduce","acc","lastKey","pop","key"],"sourceRoot":""}