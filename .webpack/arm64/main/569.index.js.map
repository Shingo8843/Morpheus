{"version":3,"file":"569.index.js","mappings":"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A,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,KACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,GACA,IACA,GACA,IACA,GACA,IACA,K,eChMJ,MAAMC,GAAY,CACdC,QAAS,MACTC,OAAQ,OACRC,KAAM,OACNC,KAAM,OACNC,KAAM,MACNC,IAAK,MACLC,KAAM,KACNC,MAAO,MACPC,IAAK,IACLC,MAAO,MACPC,QAAS,MACTC,MAAO,MACPC,KAAM,MACNC,MAAO,KACPC,QAAS,MACTC,QAAS,MACTC,QAAS,MACTC,MAAO,KACPC,MAAO,MACPC,OAAQ,MACRC,KAAM,OAEJC,GAAY,CACdC,MAAO,KACPC,MAAO,GACPC,MAAO,KACPC,MAAO,KACPC,KAAM,KACNC,IAAK,GACLC,KAAM,IAKJ5T,GAAI,WAEJ+I,GAAIvH,qBAEJqS,GAAI7T,GAAI,WAER8T,GAAO,KAAO/K,GAAI,KAAO8K,GAAI9K,GAE7BgL,GAAO,KAAOhL,GAAI,KAAO8K,GAAI9K,GAAI,IAAM8K,GAAI,MAE3CG,GAAO,KAAOjL,GAAI,KAAO8K,GAAI9K,GAAI8K,GAAI9K,GAErCkL,GAAM,KAAOlL,GAAI,KAAO/I,GACvB,SAAS,GAAQ0B,GACpB,IAAIwS,EACAC,EACAC,EACAC,EACAC,EACAC,EACJ,GAAI7S,EAAEjJ,OAAS,EACX,OAAOiJ,EAEX,MAAM8S,EAAU9S,EAAE6B,UAAU,EAAG,GAa/B,GAZe,KAAXiR,IACA9S,EAAI8S,EAAQC,cAAgB/S,EAAE6B,UAAU,IAE5C6Q,EAAK,kBACLC,EAAM,iBACFD,EAAG5Y,KAAKkG,GACRA,EAAIA,EAAEgT,QAAQN,EAAI,QACXC,EAAI7Y,KAAKkG,KAChBA,EAAIA,EAAEgT,QAAQL,EAAK,SAEvBD,EAAK,aACLC,EAAM,kBACFD,EAAG5Y,KAAKkG,GAAI,CACZ,MAAMiT,EAAKP,EAAGQ,KAAKlT,GACnB0S,EAAK,IAAIS,OAAOf,IACZM,EAAG5Y,KAAKmZ,EAAG,MACXP,EAAK,KACL1S,EAAIA,EAAEgT,QAAQN,EAAI,IAE1B,MAAWC,EAAI7Y,KAAKkG,KAEhBwS,EADWG,EAAIO,KAAKlT,GACV,GACV2S,EAAM,IAAIQ,OAAOZ,IACbI,EAAI7Y,KAAK0Y,KACTxS,EAAIwS,EACJG,EAAM,cACNC,EAAM,IAAIO,OAAO,sBACjBN,EAAM,IAAIM,OAAO,IAAM9L,GAAI/I,GAAI,gBAC3BqU,EAAI7Y,KAAKkG,GACTA,GAAQ,IACD4S,EAAI9Y,KAAKkG,IAChB0S,EAAK,KACL1S,EAAIA,EAAEgT,QAAQN,EAAI,KACXG,EAAI/Y,KAAKkG,KAChBA,GAAQ,OAKpB,GADA0S,EAAK,WACDA,EAAG5Y,KAAKkG,GAAI,CACZ,MAAMiT,EAAKP,EAAGQ,KAAKlT,GACnBwS,EAAOS,aAA+B,EAASA,EAAG,GAClDP,EAAK,IAAIS,OAAOZ,IACZC,GAAQE,EAAG5Y,KAAK0Y,KAChBxS,EAAIwS,EAAO,IAEnB,CAEA,GADAE,EAAK,2IACDA,EAAG5Y,KAAKkG,GAAI,CACZ,MAAMiT,EAAKP,EAAGQ,KAAKlT,GACnBwS,EAAOS,aAA+B,EAASA,EAAG,GAClDR,EAASQ,aAA+B,EAASA,EAAG,GACpDP,EAAK,IAAIS,OAAOf,IACZI,GAAQE,EAAG5Y,KAAK0Y,KAGhBxS,EAAIwS,EAAOnC,GAAUoC,GAE7B,CAEA,GADAC,EAAK,iDACDA,EAAG5Y,KAAKkG,GAAI,CACZ,MAAMiT,EAAKP,EAAGQ,KAAKlT,GACnBwS,EAAOS,aAA+B,EAASA,EAAG,GAClDR,EAASQ,aAA+B,EAASA,EAAG,GACpDP,EAAK,IAAIS,OAAOf,IAGZI,GAAQE,EAAG5Y,KAAK0Y,KAGhBxS,EAAIwS,EAAOb,GAAUc,GAE7B,CAGA,GAFAC,EAAK,sFACLC,EAAM,oBACFD,EAAG5Y,KAAKkG,GAAI,CACZ,MAAMiT,EAAKP,EAAGQ,KAAKlT,GACnBwS,EAAOS,aAA+B,EAASA,EAAG,GAClDP,EAAK,IAAIS,OAAOb,IACZE,GAAQE,EAAG5Y,KAAK0Y,KAChBxS,EAAIwS,EAEZ,MAAO,GAAIG,EAAI7Y,KAAKkG,GAAI,CACpB,MAAMiT,EAAKN,EAAIO,KAAKlT,GACpBwS,GAAQS,aAA+B,EAASA,EAAG,KAAO,IAAMA,aAA+B,EAASA,EAAG,KAAO,GAClHN,EAAM,IAAIQ,OAAOb,IACbK,EAAI7Y,KAAK0Y,KACTxS,EAAIwS,EAEZ,CAEA,GADAE,EAAK,WACDA,EAAG5Y,KAAKkG,GAAI,CACZ,MAAMiT,EAAKP,EAAGQ,KAAKlT,GACnBwS,EAAOS,aAA+B,EAASA,EAAG,GAClDP,EAAK,IAAIS,OAAOb,IAChBK,EAAM,IAAIQ,OAAOd,IACjBO,EAAM,IAAIO,OAAO,IAAM9L,GAAI/I,GAAI,gBAC3BkU,IAASE,EAAG5Y,KAAK0Y,IAASG,EAAI7Y,KAAK0Y,KAAUI,EAAI9Y,KAAK0Y,MACtDxS,EAAIwS,EAEZ,CAUA,OATAE,EAAK,MACLC,EAAM,IAAIQ,OAAOb,IACbI,EAAG5Y,KAAKkG,IAAM2S,EAAI7Y,KAAKkG,KACvB0S,EAAK,KACL1S,EAAIA,EAAEgT,QAAQN,EAAI,KAEP,KAAXI,IACA9S,EAAI8S,EAAQhP,cAAgB9D,EAAE6B,UAAU,IAErC7B,CACX,CCxKA,SAASoT,GAAe7a,EAAMwP,GAC1B,IAAIsL,EACJ,MAAM5U,EAAM,GAAGkB,KAAK9E,YAAYtC,KAAQwP,IACxC,OAAIpI,KAAK2T,mBAAmBnJ,IAAI1L,GACrBkB,KAAK2T,mBAAmB1X,IAAI6C,IAGI,QAAtC4U,EAAkB1T,KAAK4T,iBAA2C,IAApBF,OAA6B,EAASA,EAAgBjU,SAAS2I,KAC9GpI,KAAK2T,mBAAmB7X,IAAIgD,EAAK,IAC1B,KAGPkB,KAAK6T,UAAY7T,KAAK8T,sBAAsBtJ,IAAI5R,KAChDwP,EAAQpI,KAAK6T,QAAQzL,IAEzBA,EFqLG,SAA2B2L,GAC9B,MAAMC,EAAiB,GACvB,IAAI,IAAItG,EAAM,EAAGA,EAAMqG,EAAI3c,OAAQsW,IAC/BsG,EAAetG,IAPFuG,EAOqBF,EAAIG,WAAWxG,IANtC6C,IAA6B0D,EAAWzD,GAAgCyD,EAC1DxD,GAAyBwD,EAAW1D,KAA8B0D,EAFnG,IAAqBA,EASjB,OAAOE,OAAOC,gBAAgBJ,EAClC,CE3LYK,CAAkBjM,GAC1BpI,KAAK2T,mBAAmB7X,IAAIgD,EAAKsJ,GAC1BA,EACX,CAUA,SAASmC,GAAS+J,EAAOpZ,EAAUtC,GAC/B,GAAIsC,GAAYA,IAAa8E,KAAK9E,SAC9B,MAAM,OAAY,yBAA0BA,GAEzB,GAAqB,iBAAVoZ,EAC9B,MAAO,CACHA,GAGR,IAAIxM,EACJ,GAAIlP,GAAQoH,KAAKuU,uBAAuB/J,IAAI5R,GACxCkP,EAAS,CACL9H,KAAKyT,eAAepE,KAAKrP,KAAMpH,GAAQ,GAAvCoH,CAA2CsU,QAE5C,CACH,MAAME,EAAY,MAAUxU,KAAK9E,UACjC4M,EAASwM,EAAMnQ,cAAcsQ,MAAMD,GAAW7U,IAAIK,KAAKyT,eAAepE,KAAKrP,KAAMpH,GAAQ,KAAKuG,OAAOuV,QACzG,CACA,MAAMC,EA3Bc,SAAcC,GAClC,KAAgC,KAA1BA,EAAKA,EAAKxd,OAAS,IACrBwd,EAAK9Q,MAET,KAAkB,KAAZ8Q,EAAK,IACPA,EAAKC,QAET,OAAOD,CACX,CAmBuBE,CAAKhN,GACxB,OAAK9H,KAAK+U,gBAGHJ,EAFI1b,MAAM6D,KAAK,IAAIwE,IAAIqT,GAGlC,CACO1c,eAAe+c,GAAgBtG,EAAS,CAAC,GAC5C,GAAKA,EAAOxT,UAEL,IAAK,MAAoBuE,SAASiP,EAAOxT,UAC5C,MAAM,OAAY,yBAA0BwT,EAAOxT,eAFnDwT,EAAOxT,SAAW,UAKtB,IAAI2Y,EAgBAD,EAfJ,GAAIlF,EAAOuG,UAAYvG,EAAOmF,WAAa,aAAcnF,GACrD,GAAIA,EAAOmF,QAAS,CAChB,GAA8B,mBAAnBnF,EAAOmF,QACd,MAAM,OAAY,iCAEtBA,EAAUnF,EAAOmF,OACrB,KAAO,CACH,GAAwB,YAApBnF,EAAOxT,SAGP,MAAM,OAAY,kBAAmBwT,EAAOxT,UAF5C2Y,EAAU,EAIlB,CAIJ,IAAyB,IAArBnF,EAAOkF,UAAqB,CAE5B,GADAA,EAAY,GACR3a,MAAMC,QAAQwV,EAAOkF,WACrBA,EAAYlF,EAAOkF,eAChB,GAAgC,mBAArBlF,EAAOkF,UACrBA,QAAkBlF,EAAOkF,UAAUA,QAChC,GAAIlF,EAAOkF,UACd,MAAM,OAAY,+CAGtB,IAAK3a,MAAMC,QAAQ0a,GACf,MAAM,OAAY,+CAEtB,IAAK,MAAM3T,KAAK2T,EACZ,GAAiB,iBAAN3T,EACP,MAAM,OAAY,8CAG9B,CAEA,MAAMiK,EAAY,CACdK,YACArP,SAAUwT,EAAOxT,SACjB2Y,UACAC,sBAAuB,IAAIxS,IAAIoN,EAAOoF,sBAAwB,CAC1DpF,EAAOoF,uBACTlH,OAAS,IACX2H,uBAAwB,IAAIjT,IAAIoN,EAAO6F,uBAAyB,CAC5D7F,EAAO6F,wBACT3H,OAAS,IACXgH,YACAmB,gBAAiBL,QAAQhG,EAAOqG,iBAChCtB,kBACAE,mBAAoB,IAAIpY,KAI5B,OAFA2O,EAAUK,SAAWA,GAAS8E,KAAKnF,GACnCA,EAAUuJ,eAAiBA,GACpBvJ,CACX,CCpFOjS,eAAe,IAAO,OAAEU,EAAO,KAAEb,EAAK,SAAEoD,EAAS,WAAEga,EAAW,GAAEzc,EAAG,QAAE+E,IACnE0X,IACDA,EAAa,CAAC,GAEbzc,IACDA,QAAW,WAEf,IAAIyR,EAAYgL,EAAWhL,UACvBvJ,EAAQuU,EAAWvU,MACnBwU,EAAiBD,EAAWC,eAC5BlH,EAASiH,EAAWjH,OAaxB,GAZK/D,EAKOA,EAAUK,WAElBL,QAAkB8K,GAAgB9K,IALlCA,QAAkB8K,GAAgB,CAC9B9Z,SAAUA,GAAY,YAS1Bga,EAAWhL,WAAahP,EAExB,MAAM,OAAY,qCAEtB,MAAMka,GAAwB,UAC9BzU,UL2cG1I,iBACH,MAAO,CACHqE,OAAM,GACN+Y,OAAM,GACNrY,OAAM,GACN6K,gCACAM,6BACAM,gCACAE,6BACAC,yBACAiD,UACAE,uBACAkB,2BACAC,oCACAxR,KAAI,GACJD,KAAI,GAEZ,CK5doB6Z,GAChBrH,UJ8LGhW,iBACH,MAAO,CACHqE,OAAM,GACN+Y,OAAM,GACNrY,OAAM,GACNvB,KAAI,GACJC,KAAI,GACJ8T,UACAW,yBACAC,kCAER,CIzMqBmF,GACjBJ,UXJGld,iBACH,MAAO,CACHqE,SACAL,MACAU,cACAI,SACApB,QACAqB,SACAN,QACAhB,OACAD,OAER,CWR6B+Z,GAtD7B,SAA4BN,GACxB,MAAMO,EAAoB,CACtBvd,kBAAiB,oBACjBK,mBAAkB,qBAClBmd,sBAAqB,KACrBhd,eAAc,kBAElB,IAAK,MAAMid,KAAU,KAAoB,CACrC,MAAM7W,EAAM6W,EACZ,GAAIT,EAAWpW,IACX,GAA+B,mBAApBoW,EAAWpW,GAClB,MAAM,OAAY,6BAA8BA,QAIpDoW,EAAWpW,GAAO2W,EAAkB3W,EAE5C,CACA,IAAK,MAAM6W,KAAUle,OAAO6H,KAAK4V,GAC7B,IAAK,KAAkBzV,SAASkW,KAAY,KAAoBlW,SAASkW,GACrE,MAAM,OAAY,wBAAyBA,EAGvD,CAiCIC,CAAmBV,GAEnB,MAAM,sBAAEQ,EAAsB,mBAAEnd,EAAmB,eAAEG,EAAe,kBAAER,GAAuBgd,EACvFva,EAAQ,CACVkb,KAAM,CAAC,EACPC,OAAQ,CAAC,EACTnd,SACAuR,YACAvJ,QACAsN,SACAkH,iBACAvZ,wBAAyBwZ,EACzBM,wBACAnd,qBACAG,iBACAqd,aAAc,GACdC,YAAa,GACbC,aAAc,GACdC,YAAa,GACbC,aAAc,GACdC,YAAa,GACbC,aAAc,GACdC,YAAa,GACbC,qBAAsB,GACtBC,oBAAqB,GACrBC,qBAAsB,GACtBC,oBAAqB,GACrBC,oBAAqB,GACrBC,qBAAsB,GACtB1e,oBACAO,KACA+E,WAEJ7C,EAAMkb,KAAO,CACTlV,YAAahG,EAAMgG,MAAMrE,OAAO3B,EAAOya,EAAuBzc,GAC9D8D,WAAY9B,EAAMwa,eAAe7Y,OAAO3B,EAAOya,GAC/CyB,cAAelc,EAAMsT,OAAO3R,OAAO3B,EAAOya,EAAuBzc,EAAQb,IAE7E,IAAK,MAAMsF,KAAQF,EACfvC,EAAMyC,IAASzC,EAAMyC,IAAS,IAAI0Z,aAAa3Z,EAAoBxC,EAAOyC,IAE9E,OAAOzC,CACX,C","sources":["webpack://morpheus/./node_modules/@orama/orama/dist/components/cosine-similarity.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/defaults.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/hooks.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/internal-document-id-store.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/documents-store.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/plugins.js","webpack://morpheus/./node_modules/@orama/orama/dist/trees/avl.js","webpack://morpheus/./node_modules/@orama/orama/dist/trees/flat.js","webpack://morpheus/./node_modules/@orama/orama/dist/trees/radix.js","webpack://morpheus/./node_modules/@orama/orama/dist/trees/bkd.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/index.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/sorter.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/tokenizer/diacritics.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/tokenizer/english-stemmer.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/tokenizer/index.js","webpack://morpheus/./node_modules/@orama/orama/dist/methods/create.js"],"sourcesContent":["export function getMagnitude(vector, vectorLength) {\n    let magnitude = 0;\n    for(let i = 0; i < vectorLength; i++){\n        magnitude += vector[i] * vector[i];\n    }\n    return Math.sqrt(magnitude);\n}\n// @todo: Write plugins for Node and Browsers to use parallel computation for this function\nexport function findSimilarVectors(targetVector, vectors, length, threshold = 0.8) {\n    const targetMagnitude = getMagnitude(targetVector, length);\n    const similarVectors = [];\n    for (const [vectorId, [magnitude, vector]] of Object.entries(vectors)){\n        let dotProduct = 0;\n        for(let i = 0; i < length; i++){\n            dotProduct += targetVector[i] * vector[i];\n        }\n        const similarity = dotProduct / (targetMagnitude * magnitude);\n        if (similarity >= threshold) {\n            similarVectors.push([\n                vectorId,\n                similarity\n            ]);\n        }\n    }\n    return similarVectors.sort((a, b)=>b[1] - a[1]);\n}\n\n//# sourceMappingURL=cosine-similarity.js.map","import { createError } from '../errors.js';\nimport { formatNanoseconds, uniqueId } from '../utils.js';\nexport { getDocumentProperties } from '../utils.js';\nexport async function formatElapsedTime(n) {\n    return {\n        raw: Number(n),\n        formatted: await formatNanoseconds(n)\n    };\n}\nexport async function getDocumentIndexId(doc) {\n    if (doc.id) {\n        if (typeof doc.id !== 'string') {\n            throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof doc.id);\n        }\n        return doc.id;\n    }\n    return await uniqueId();\n}\nexport async function validateSchema(doc, schema) {\n    for (const [prop, type] of Object.entries(schema)){\n        const value = doc[prop];\n        if (typeof value === 'undefined') {\n            continue;\n        }\n        if (type === 'geopoint' && typeof value === 'object' && typeof value.lon === 'number' && typeof value.lat === 'number') {\n            continue;\n        }\n        if (type === 'enum' && (typeof value === 'string' || typeof value === 'number')) {\n            continue;\n        }\n        if (type === 'enum[]' && Array.isArray(value)) {\n            const valueLength = value.length;\n            for(let i = 0; i < valueLength; i++){\n                if (typeof value[i] !== 'string' && typeof value[i] !== 'number') {\n                    return prop + '.' + i;\n                }\n            }\n            continue;\n        }\n        if (isVectorType(type)) {\n            const vectorSize = getVectorSize(type);\n            if (!Array.isArray(value) || value.length !== vectorSize) {\n                throw createError('INVALID_INPUT_VECTOR', prop, vectorSize, value.length);\n            }\n            continue;\n        }\n        if (isArrayType(type)) {\n            if (!Array.isArray(value)) {\n                return prop;\n            }\n            const expectedType = getInnerType(type);\n            const valueLength = value.length;\n            for(let i = 0; i < valueLength; i++){\n                if (typeof value[i] !== expectedType) {\n                    return prop + '.' + i;\n                }\n            }\n            continue;\n        }\n        if (typeof type === 'object') {\n            if (!value || typeof value !== 'object') {\n                return prop;\n            }\n            // using as ResultDocument is not exactly right but trying to be type-safe here is not useful\n            const subProp = await validateSchema(value, type);\n            if (subProp) {\n                return prop + '.' + subProp;\n            }\n            continue;\n        }\n        if (typeof value !== type) {\n            return prop;\n        }\n    }\n    return undefined;\n}\nconst IS_ARRAY_TYPE = {\n    string: false,\n    number: false,\n    boolean: false,\n    enum: false,\n    geopoint: false,\n    'string[]': true,\n    'number[]': true,\n    'boolean[]': true,\n    'enum[]': true\n};\nconst INNER_TYPE = {\n    'string[]': 'string',\n    'number[]': 'number',\n    'boolean[]': 'boolean',\n    'enum[]': 'enum'\n};\nexport function isGeoPointType(type) {\n    return type === 'geopoint';\n}\nexport function isVectorType(type) {\n    return typeof type === 'string' && /^vector\\[\\d+\\]$/.test(type);\n}\nexport function isArrayType(type) {\n    return typeof type === 'string' && IS_ARRAY_TYPE[type];\n}\nexport function getInnerType(type) {\n    return INNER_TYPE[type];\n}\nexport function getVectorSize(type) {\n    const size = Number(type.slice(7, -1));\n    switch(true){\n        case isNaN(size):\n            throw createError('INVALID_VECTOR_VALUE', type);\n        case size <= 0:\n            throw createError('INVALID_VECTOR_SIZE', type);\n        default:\n            return size;\n    }\n}\n\n//# sourceMappingURL=defaults.js.map","export const OBJECT_COMPONENTS = [\n    'tokenizer',\n    'index',\n    'documentsStore',\n    'sorter'\n];\nexport const FUNCTION_COMPONENTS = [\n    'validateSchema',\n    'getDocumentIndexId',\n    'getDocumentProperties',\n    'formatElapsedTime'\n];\nexport const SINGLE_OR_ARRAY_COMPONENTS = [];\nexport async function runSingleHook(hooks, orama, id, doc) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](orama, id, doc);\n    }\n}\nexport async function runMultipleHook(hooks, orama, docsOrIds) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](orama, docsOrIds);\n    }\n}\nexport async function runAfterSearch(hooks, db, params, language, results) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](db, params, language, results);\n    }\n}\nexport async function runBeforeSearch(hooks, db, params, language) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](db, params, language);\n    }\n}\n\n//# sourceMappingURL=hooks.js.map","export function createInternalDocumentIDStore() {\n    return {\n        idToInternalId: new Map(),\n        internalIdToId: [],\n        save,\n        load\n    };\n}\nexport function save(store) {\n    return {\n        internalIdToId: store.internalIdToId\n    };\n}\nexport function load(orama, raw) {\n    const { internalIdToId  } = raw;\n    orama.internalDocumentIDStore.idToInternalId.clear();\n    orama.internalDocumentIDStore.internalIdToId = [];\n    for(let i = 0; i < internalIdToId.length; i++){\n        orama.internalDocumentIDStore.idToInternalId.set(internalIdToId[i], i + 1);\n        orama.internalDocumentIDStore.internalIdToId.push(internalIdToId[i]);\n    }\n}\nexport function getInternalDocumentId(store, id) {\n    if (typeof id === 'string') {\n        const internalId = store.idToInternalId.get(id);\n        if (internalId) {\n            return internalId;\n        }\n        const currentId = store.idToInternalId.size + 1;\n        store.idToInternalId.set(id, currentId);\n        store.internalIdToId.push(id);\n        return currentId;\n    }\n    if (id > store.internalIdToId.length) {\n        return getInternalDocumentId(store, id.toString());\n    }\n    return id;\n}\nexport function getDocumentIdFromInternalId(store, internalId) {\n    if (store.internalIdToId.length < internalId) {\n        throw new Error(`Invalid internalId ${internalId}`);\n    }\n    return store.internalIdToId[internalId - 1];\n}\n\n//# sourceMappingURL=internal-document-id-store.js.map","import { getInternalDocumentId } from './internal-document-id-store.js';\nexport async function create(_, sharedInternalDocumentStore) {\n    return {\n        sharedInternalDocumentStore,\n        docs: {},\n        count: 0\n    };\n}\nexport async function get(store, id) {\n    const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, id);\n    return store.docs[internalId];\n}\nexport async function getMultiple(store, ids) {\n    const found = Array.from({\n        length: ids.length\n    });\n    for(let i = 0; i < ids.length; i++){\n        const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, ids[i]);\n        found[i] = store.docs[internalId];\n    }\n    return found;\n}\nexport async function getAll(store) {\n    return store.docs;\n}\nexport async function store(store, id, doc) {\n    const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, id);\n    if (typeof store.docs[internalId] !== 'undefined') {\n        return false;\n    }\n    store.docs[internalId] = doc;\n    store.count++;\n    return true;\n}\nexport async function remove(store, id) {\n    const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, id);\n    if (typeof store.docs[internalId] === 'undefined') {\n        return false;\n    }\n    delete store.docs[internalId];\n    store.count--;\n    return true;\n}\nexport async function count(store) {\n    return store.count;\n}\nexport async function load(sharedInternalDocumentStore, raw) {\n    const rawDocument = raw;\n    return {\n        docs: rawDocument.docs,\n        count: rawDocument.count,\n        sharedInternalDocumentStore\n    };\n}\nexport async function save(store) {\n    return {\n        docs: store.docs,\n        count: store.count\n    };\n}\nexport async function createDocumentsStore() {\n    return {\n        create,\n        get,\n        getMultiple,\n        getAll,\n        store,\n        remove,\n        count,\n        load,\n        save\n    };\n}\n\n//# sourceMappingURL=documents-store.js.map","import { createError } from '../errors.js';\nexport const AVAILABLE_PLUGIN_HOOKS = [\n    'beforeInsert',\n    'afterInsert',\n    'beforeRemove',\n    'afterRemove',\n    'beforeUpdate',\n    'afterUpdate',\n    'beforeSearch',\n    'afterSearch',\n    'beforeInsertMultiple',\n    'afterInsertMultiple',\n    'beforeRemoveMultiple',\n    'afterRemoveMultiple',\n    'beforeUpdateMultiple',\n    'afterUpdateMultiple',\n    'beforeLoad',\n    'afterLoad'\n];\nexport async function getAllPluginsByHook(orama, hook) {\n    var _orama_plugins;\n    const pluginsToRun = [];\n    const pluginsLength = (_orama_plugins = orama.plugins) === null || _orama_plugins === void 0 ? void 0 : _orama_plugins.length;\n    if (!pluginsLength) {\n        return pluginsToRun;\n    }\n    for(let i = 0; i < pluginsLength; i++){\n        try {\n            const plugin = await orama.plugins[i];\n            if (typeof plugin[hook] === 'function') {\n                pluginsToRun.push(plugin[hook]);\n            }\n        } catch (error) {\n            console.error('Caught error in getAllPluginsByHook:', error);\n            throw createError('PLUGIN_CRASHED');\n        }\n    }\n    return pluginsToRun;\n}\n\n//# sourceMappingURL=plugins.js.map","import { safeArrayPush } from '../utils.js';\nfunction rotateLeft(node) {\n    const right = node.r;\n    node.r = right.l;\n    right.l = node;\n    node.h = Math.max(getHeight(node.l), getHeight(node.r)) + 1;\n    right.h = Math.max(getHeight(right.l), getHeight(right.r)) + 1;\n    return right;\n}\nfunction rotateRight(node) {\n    const left = node.l;\n    node.l = left.r;\n    left.r = node;\n    node.h = Math.max(getHeight(node.l), getHeight(node.r)) + 1;\n    left.h = Math.max(getHeight(left.l), getHeight(left.r)) + 1;\n    return left;\n}\nexport function contains(node, key) {\n    return !!find(node, key);\n}\nexport function getSize(root) {\n    let size = 0;\n    const queue = [];\n    if (root !== null) {\n        queue.push(root.root);\n    }\n    while(queue.length > 0){\n        const node = queue.shift();\n        size++;\n        if (node.l !== null) {\n            queue.push(node.l);\n        }\n        if (node.r !== null) {\n            queue.push(node.r);\n        }\n    }\n    return size;\n}\nexport function isBalanced(root) {\n    if (root === null) return true;\n    const stack = [\n        root.root\n    ];\n    while(stack.length > 0){\n        const node = stack.pop();\n        if (node != null) {\n            const leftHeight = getHeight(node.l);\n            const rightHeight = getHeight(node.r);\n            const heightDiff = leftHeight - rightHeight;\n            if (Math.abs(heightDiff) > 1) {\n                return false;\n            }\n            if (node.l !== null) {\n                stack.push(node.l);\n            }\n            if (node.r !== null) {\n                stack.push(node.r);\n            }\n        }\n    }\n    return true;\n}\nexport function rangeSearch(node, min, max) {\n    const result = [];\n    function traverse(node) {\n        if (node === null) {\n            return;\n        }\n        if (min < node.k) {\n            traverse(node.l);\n        }\n        if (node.k >= min && node.k <= max) {\n            safeArrayPush(result, node.v);\n        }\n        if (max > node.k) {\n            traverse(node.r);\n        }\n    }\n    traverse(node.root);\n    return result;\n}\nexport function greaterThan(node, key, inclusive = false) {\n    const result = [];\n    function traverse(node) {\n        if (node === null) {\n            return;\n        }\n        if (inclusive && node.k >= key) {\n            safeArrayPush(result, node.v);\n        }\n        if (!inclusive && node.k > key) {\n            safeArrayPush(result, node.v);\n        }\n        traverse(node.l);\n        traverse(node.r);\n    }\n    traverse(node.root);\n    return result;\n}\nexport function lessThan(node, key, inclusive = false) {\n    const result = [];\n    function traverse(node) {\n        if (node === null) {\n            return;\n        }\n        if (inclusive && node.k <= key) {\n            safeArrayPush(result, node.v);\n        }\n        if (!inclusive && node.k < key) {\n            safeArrayPush(result, node.v);\n        }\n        traverse(node.l);\n        traverse(node.r);\n    }\n    traverse(node.root);\n    return result;\n}\nfunction getNodeByKey(node, key) {\n    while(node !== null){\n        if (key < node.k) {\n            node = node.l;\n        } else if (key > node.k) {\n            node = node.r;\n        } else {\n            return node;\n        }\n    }\n    return null;\n}\nexport function create(key, value) {\n    return {\n        root: {\n            k: key,\n            v: value,\n            l: null,\n            r: null,\n            h: 0\n        }\n    };\n}\nexport function insert(rootNode, key, newValue) {\n    function insertNode(node, key, newValue) {\n        if (node === null) {\n            return {\n                k: key,\n                v: newValue,\n                l: null,\n                r: null,\n                h: 0\n            };\n        }\n        if (key < node.k) {\n            node.l = insertNode(node.l, key, newValue);\n        } else if (key > node.k) {\n            node.r = insertNode(node.r, key, newValue);\n        } else {\n            for (const value of newValue){\n                node.v.push(value);\n            }\n            return node;\n        }\n        node.h = 1 + Math.max(getHeight(node.l), getHeight(node.r));\n        const balanceFactor = getHeight(node.l) - getHeight(node.r);\n        if (balanceFactor > 1 && key < node.l.k) {\n            return rotateRight(node);\n        }\n        if (balanceFactor < -1 && key > node.r.k) {\n            return rotateLeft(node);\n        }\n        if (balanceFactor > 1 && key > node.l.k) {\n            node.l = rotateLeft(node.l);\n            return rotateRight(node);\n        }\n        if (balanceFactor < -1 && key < node.r.k) {\n            node.r = rotateRight(node.r);\n            return rotateLeft(node);\n        }\n        return node;\n    }\n    rootNode.root = insertNode(rootNode.root, key, newValue);\n}\nfunction getHeight(node) {\n    return node !== null ? node.h : -1;\n}\nexport function find(root, key) {\n    const node = getNodeByKey(root.root, key);\n    if (node === null) {\n        return null;\n    }\n    return node.v;\n}\nexport function remove(rootNode, key) {\n    if (rootNode === null || rootNode.root === null) {\n        return;\n    }\n    let node = rootNode.root;\n    let parentNode = null;\n    while(node != null && node.k !== key){\n        parentNode = node;\n        if (key < node.k) {\n            node = node.l;\n        } else {\n            node = node.r;\n        }\n    }\n    if (node === null) {\n        return;\n    }\n    const deleteNode = ()=>{\n        if (node.l === null && node.r === null) {\n            if (parentNode === null) {\n                rootNode.root = null;\n            } else {\n                if (parentNode.l === node) {\n                    parentNode.l = null;\n                } else {\n                    parentNode.r = null;\n                }\n            }\n        } else if (node.l != null && node.r != null) {\n            let minValueNode = node.r;\n            let minValueParent = node;\n            while(minValueNode.l != null){\n                minValueParent = minValueNode;\n                minValueNode = minValueNode.l;\n            }\n            node.k = minValueNode.k;\n            if (minValueParent === node) {\n                minValueParent.r = minValueNode.r;\n            } else {\n                minValueParent.l = minValueNode.r;\n            }\n        } else {\n            const childNode = node.l != null ? node.l : node.r;\n            if (parentNode === null) {\n                rootNode.root = childNode;\n            } else {\n                if (parentNode.l === node) {\n                    parentNode.l = childNode;\n                } else {\n                    parentNode.r = childNode;\n                }\n            }\n        }\n    };\n    deleteNode();\n}\nexport function removeDocument(root, id, key) {\n    const node = getNodeByKey(root.root, key);\n    if (!node) {\n        return;\n    }\n    if (node.v.length === 1) {\n        remove(root, key);\n        return;\n    }\n    node.v.splice(node.v.indexOf(id), 1);\n}\n\n//# sourceMappingURL=avl.js.map","import { intersect, safeArrayPush } from '../utils.js';\nexport function create() {\n    return {\n        numberToDocumentId: new Map()\n    };\n}\nexport function insert(root, key, value) {\n    if (root.numberToDocumentId.has(key)) {\n        root.numberToDocumentId.get(key).push(value);\n        return root;\n    }\n    root.numberToDocumentId.set(key, [\n        value\n    ]);\n    return root;\n}\nexport function find(root, key) {\n    return root.numberToDocumentId.get(key) ?? null;\n}\nexport function remove(root, key) {\n    if (root != null) {\n        root.numberToDocumentId.delete(key);\n    }\n    return root;\n}\nexport function removeDocument(root, id, key) {\n    var _root_numberToDocumentId_get, _root_numberToDocumentId_get1;\n    root === null || root === void 0 ? void 0 : root.numberToDocumentId.set(key, ((_root_numberToDocumentId_get = root === null || root === void 0 ? void 0 : root.numberToDocumentId.get(key)) === null || _root_numberToDocumentId_get === void 0 ? void 0 : _root_numberToDocumentId_get.filter((v)=>v !== id)) ?? []);\n    if (((_root_numberToDocumentId_get1 = root === null || root === void 0 ? void 0 : root.numberToDocumentId.get(key)) === null || _root_numberToDocumentId_get1 === void 0 ? void 0 : _root_numberToDocumentId_get1.length) === 0) {\n        root === null || root === void 0 ? void 0 : root.numberToDocumentId.delete(key);\n    }\n}\nexport function contains(node, key) {\n    return !(find(node, key) == null);\n}\nexport function getSize(root) {\n    let size = 0;\n    for (const [, value] of (root === null || root === void 0 ? void 0 : root.numberToDocumentId) ?? []){\n        size += value.length;\n    }\n    return size;\n}\nexport function filter(root, operation) {\n    const operationKeys = Object.keys(operation);\n    if (operationKeys.length !== 1) {\n        throw new Error('Invalid operation');\n    }\n    const operationType = operationKeys[0];\n    switch(operationType){\n        case 'eq':\n            {\n                const value = operation[operationType];\n                return root.numberToDocumentId.get(value) ?? [];\n            }\n        case 'in':\n            {\n                const value = operation[operationType];\n                const result = [];\n                for (const v of value){\n                    const ids = root.numberToDocumentId.get(v);\n                    if (ids != null) {\n                        safeArrayPush(result, ids);\n                    }\n                }\n                return result;\n            }\n        case 'nin':\n            {\n                const value = operation[operationType];\n                const result = [];\n                const keys = root.numberToDocumentId.keys();\n                for (const key of keys){\n                    if (value.includes(key)) {\n                        continue;\n                    }\n                    const ids = root.numberToDocumentId.get(key);\n                    if (ids != null) {\n                        safeArrayPush(result, ids);\n                    }\n                }\n                return result;\n            }\n    }\n    throw new Error('Invalid operation');\n}\nexport function filterArr(root, operation) {\n    const operationKeys = Object.keys(operation);\n    if (operationKeys.length !== 1) {\n        throw new Error('Invalid operation');\n    }\n    const operationType = operationKeys[0];\n    switch(operationType){\n        case 'containsAll':\n            {\n                const values = operation[operationType];\n                const ids = values.map((value)=>root.numberToDocumentId.get(value) ?? []);\n                return intersect(ids);\n            }\n    }\n    throw new Error('Invalid operation');\n}\n\n//# sourceMappingURL=flat.js.map","import { syncBoundedLevenshtein } from '../components/levenshtein.js';\nimport { getOwnProperty } from '../utils.js';\nexport class Node {\n    constructor(key, subWord, end){\n        this.k = key;\n        this.s = subWord;\n        this.e = end;\n    }\n    // Node children\n    c = {};\n    // Node documents\n    d = [];\n    // Node word\n    w = '';\n    toJSON() {\n        return {\n            w: this.w,\n            s: this.s,\n            c: this.c,\n            d: this.d,\n            e: this.e\n        };\n    }\n}\nfunction updateParent(node, parent) {\n    node.w = parent.w + node.s;\n}\nfunction addDocument(node, docID) {\n    node.d.push(docID);\n}\nfunction removeDocument(node, docID) {\n    const index = node.d.indexOf(docID);\n    /* c8 ignore next 3 */ if (index === -1) {\n        return false;\n    }\n    node.d.splice(index, 1);\n    return true;\n}\nfunction findAllWords(node, output, term, exact, tolerance) {\n    if (node.e) {\n        const { w , d: docIDs  } = node;\n        if (exact && w !== term) {\n            return {};\n        }\n        // always check in own property to prevent access to inherited properties\n        // fix https://github.com/OramaSearch/orama/issues/137\n        if (getOwnProperty(output, w) == null) {\n            if (tolerance) {\n                // computing the absolute difference of letters between the term and the word\n                const difference = Math.abs(term.length - w.length);\n                // if the tolerance is set, check whether the edit distance is within tolerance.\n                // In that case, we don't need to add the word to the output\n                if (difference <= tolerance && syncBoundedLevenshtein(term, w, tolerance).isBounded) {\n                    output[w] = [];\n                }\n            } else {\n                // prevent default tolerance not set\n                output[w] = [];\n            }\n        }\n        // check if _output[w] exists and then add the doc to it\n        // always check in own property to prevent access to inherited properties\n        // fix https://github.com/OramaSearch/orama/issues/137\n        if (getOwnProperty(output, w) != null && docIDs.length > 0) {\n            const docs = new Set(output[w]);\n            const docIDsLength = docIDs.length;\n            for(let i = 0; i < docIDsLength; i++){\n                docs.add(docIDs[i]);\n            }\n            output[w] = Array.from(docs);\n        }\n    }\n    // recursively search the children\n    for (const character of Object.keys(node.c)){\n        findAllWords(node.c[character], output, term, exact, tolerance);\n    }\n    return output;\n}\nfunction getCommonPrefix(a, b) {\n    let commonPrefix = '';\n    const len = Math.min(a.length, b.length);\n    for(let i = 0; i < len; i++){\n        if (a[i] !== b[i]) {\n            return commonPrefix;\n        }\n        commonPrefix += a[i];\n    }\n    return commonPrefix;\n}\nexport function create(end = false, subWord = '', key = '') {\n    return new Node(key, subWord, end);\n}\nexport function insert(root, word, docId) {\n    const wordLength = word.length;\n    for(let i = 0; i < wordLength; i++){\n        const currentCharacter = word[i];\n        const wordAtIndex = word.substring(i);\n        const rootChildCurrentChar = root.c[currentCharacter];\n        if (rootChildCurrentChar) {\n            const edgeLabel = rootChildCurrentChar.s;\n            const edgeLabelLength = edgeLabel.length;\n            const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex);\n            const commonPrefixLength = commonPrefix.length;\n            // the wordAtIndex matches exactly with an existing child node\n            if (edgeLabel === wordAtIndex) {\n                addDocument(rootChildCurrentChar, docId);\n                rootChildCurrentChar.e = true;\n                return;\n            }\n            const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength];\n            // the wordAtIndex is completely contained in the child node subword\n            if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n                const newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true\n                ;\n                newNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar;\n                const newNodeChild = newNode.c[edgeLabelAtCommonPrefix];\n                newNodeChild.s = edgeLabel.substring(commonPrefixLength);\n                newNodeChild.k = edgeLabelAtCommonPrefix;\n                root.c[currentCharacter] = newNode;\n                updateParent(newNode, root);\n                updateParent(newNodeChild, newNode);\n                addDocument(newNode, docId);\n                return;\n            }\n            // the wordAtIndex is partially contained in the child node subword\n            if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n                const inbetweenNode = create(false, commonPrefix, currentCharacter);\n                inbetweenNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar;\n                root.c[currentCharacter] = inbetweenNode;\n                const inbetweenNodeChild = inbetweenNode.c[edgeLabelAtCommonPrefix];\n                inbetweenNodeChild.s = edgeLabel.substring(commonPrefixLength);\n                inbetweenNodeChild.k = edgeLabelAtCommonPrefix;\n                const wordAtCommonPrefix = wordAtIndex[commonPrefixLength];\n                const newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix);\n                addDocument(newNode, docId);\n                inbetweenNode.c[wordAtCommonPrefix] = newNode;\n                updateParent(inbetweenNode, root);\n                updateParent(newNode, inbetweenNode);\n                updateParent(inbetweenNodeChild, inbetweenNode);\n                return;\n            }\n            // skip to the next divergent character\n            i += edgeLabelLength - 1;\n            // navigate in the child node\n            root = rootChildCurrentChar;\n        } else {\n            // if the node for the current character doesn't exist create new node\n            const newNode = create(true, wordAtIndex, currentCharacter);\n            addDocument(newNode, docId);\n            root.c[currentCharacter] = newNode;\n            updateParent(newNode, root);\n            return;\n        }\n    }\n}\nfunction _findLevenshtein(node, term, index, tolerance, originalTolerance, output) {\n    if (tolerance < 0) {\n        return;\n    }\n    if (node.w.startsWith(term)) {\n        findAllWords(node, output, term, false, 0);\n        return;\n    }\n    if (node.e) {\n        const { w , d: docIDs  } = node;\n        if (w) {\n            if (syncBoundedLevenshtein(term, w, originalTolerance).isBounded) {\n                output[w] = [];\n            }\n            if (getOwnProperty(output, w) != null && docIDs.length > 0) {\n                const docs = new Set(output[w]);\n                const docIDsLength = docIDs.length;\n                for(let i = 0; i < docIDsLength; i++){\n                    docs.add(docIDs[i]);\n                }\n                output[w] = Array.from(docs);\n            }\n        }\n    }\n    if (index >= term.length) {\n        return;\n    }\n    // Match current character without consuming tolerance\n    if (term[index] in node.c) {\n        _findLevenshtein(node.c[term[index]], term, index + 1, tolerance, originalTolerance, output);\n    }\n    // If tolerance is still available, consider other branches:\n    // 1. Deletion (skip the current term character)\n    _findLevenshtein(node, term, index + 1, tolerance - 1, originalTolerance, output);\n    // 2. Insertion (skip the current tree node character)\n    for(const character in node.c){\n        _findLevenshtein(node.c[character], term, index, tolerance - 1, originalTolerance, output);\n    }\n    // 3. Substitution (skip both current term character and tree node character)\n    for(const character in node.c){\n        if (character !== term[index]) {\n            _findLevenshtein(node.c[character], term, index + 1, tolerance - 1, originalTolerance, output);\n        }\n    }\n}\nexport function find(root, { term , exact , tolerance  }) {\n    // Find the closest node to the term\n    // Use `if` condition because tolerance `0` is supposed to match only prefix.\n    // (allows infinite insertions at end, which is against normal levenshtein logic).\n    // (new _findLevenshtein only handles not exact and tolerance>0 condition)\n    if (tolerance && !exact) {\n        const output = {};\n        tolerance = tolerance || 0;\n        _findLevenshtein(root, term, 0, tolerance || 0, tolerance, output);\n        return output;\n    } else {\n        const termLength = term.length;\n        for(let i = 0; i < termLength; i++){\n            const character = term[i];\n            if (character in root.c) {\n                const rootChildCurrentChar = root.c[character];\n                const edgeLabel = rootChildCurrentChar.s;\n                const termSubstring = term.substring(i);\n                // find the common prefix between two words ex: prime and primate = prim\n                const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);\n                const commonPrefixLength = commonPrefix.length;\n                // if the common prefix length is equal to edgeLabel length (the node subword) it means they are a match\n                // if the common prefix is equal to the term means it is contained in the node\n                if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n                    // if tolerance is set we take the current node as the closest\n                    if (tolerance) break;\n                    return {};\n                }\n                // skip the subword length and check the next divergent character\n                i += rootChildCurrentChar.s.length - 1;\n                // navigate into the child node\n                root = rootChildCurrentChar;\n            } else {\n                return {};\n            }\n        }\n        const output = {};\n        // found the closest node we recursively search through children\n        findAllWords(root, output, term, exact, tolerance);\n        return output;\n    }\n}\nexport function contains(root, term) {\n    const termLength = term.length;\n    for(let i = 0; i < termLength; i++){\n        const character = term[i];\n        if (character in root.c) {\n            const rootChildrenChar = root.c[character];\n            const edgeLabel = rootChildrenChar.s;\n            const termSubstring = term.substring(i);\n            const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);\n            const commonPrefixLength = commonPrefix.length;\n            if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n                return false;\n            }\n            i += rootChildrenChar.s.length - 1;\n            root = rootChildrenChar;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\nexport function removeWord(root, term) {\n    if (!term) {\n        return false;\n    }\n    const termLength = term.length;\n    for(let i = 0; i < termLength; i++){\n        const character = term[i];\n        const parent = root;\n        if (character in root.c) {\n            i += root.c[character].s.length - 1;\n            root = root.c[character];\n            if (Object.keys(root.c).length === 0) {\n                delete parent.c[root.k];\n                return true;\n            }\n        } else {\n            return false;\n        }\n    }\n    return false;\n}\nexport function removeDocumentByWord(root, term, docID, exact = true) {\n    if (!term) {\n        return true;\n    }\n    const termLength = term.length;\n    for(let i = 0; i < termLength; i++){\n        const character = term[i];\n        if (character in root.c) {\n            const rootChildCurrentChar = root.c[character];\n            i += rootChildCurrentChar.s.length - 1;\n            root = rootChildCurrentChar;\n            if (exact && root.w !== term) {\n            // Do nothing if the exact condition is not met.\n            } else {\n                removeDocument(root, docID);\n            }\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n\n//# sourceMappingURL=radix.js.map","const K = 2 // 2D points\n;\nconst EARTH_RADIUS = 6371e3 // Earth radius in meters\n;\nexport function create() {\n    return {\n        root: null\n    };\n}\nexport function insert(tree, point, docIDs) {\n    const newNode = {\n        point,\n        docIDs\n    };\n    if (tree.root == null) {\n        tree.root = newNode;\n        return;\n    }\n    let node = tree.root;\n    let depth = 0;\n    while(node !== null){\n        // Check if the current node's point matches the new point\n        if (node.point.lon === point.lon && node.point.lat === point.lat) {\n            // Merge the new docIDs with the existing ones and remove duplicates\n            const newDocIDs = node.docIDs ?? [];\n            node.docIDs = Array.from(new Set([\n                ...newDocIDs,\n                ...docIDs || []\n            ]));\n            return;\n        }\n        const axis = depth % K;\n        // Compare by longitude\n        if (axis === 0) {\n            if (point.lon < node.point.lon) {\n                if (node.left == null) {\n                    node.left = newNode;\n                    return;\n                }\n                node = node.left;\n            } else {\n                if (node.right == null) {\n                    node.right = newNode;\n                    return;\n                }\n                node = node.right;\n            }\n        // Compare by latitude\n        } else {\n            if (point.lat < node.point.lat) {\n                if (node.left == null) {\n                    node.left = newNode;\n                    return;\n                }\n                node = node.left;\n            } else {\n                if (node.right == null) {\n                    node.right = newNode;\n                    return;\n                }\n                node = node.right;\n            }\n        }\n        depth++;\n    }\n}\nexport function contains(tree, point) {\n    let node = tree.root;\n    let depth = 0;\n    while(node != null){\n        if ((node === null || node === void 0 ? void 0 : node.point.lon) === point.lon && node.point.lat === point.lat) {\n            return true;\n        }\n        const axis = depth % K;\n        // Compare by longitude\n        if (axis === 0) {\n            if (point.lon < node.point.lon) {\n                node = node === null || node === void 0 ? void 0 : node.left;\n            } else {\n                node = node === null || node === void 0 ? void 0 : node.right;\n            }\n        // Compare by latitude\n        } else {\n            if (point.lat < node.point.lat) {\n                node = node === null || node === void 0 ? void 0 : node.left;\n            } else {\n                node = node === null || node === void 0 ? void 0 : node.right;\n            }\n        }\n        depth++;\n    }\n    return false;\n}\n// @todo: this is very inefficient. Fix this later.\nexport function removeDocByID(tree, point, docID) {\n    let node = tree.root;\n    let depth = 0;\n    let parentNode = null;\n    let direction = null;\n    while(node !== null){\n        if ((node === null || node === void 0 ? void 0 : node.point.lon) === point.lon && node.point.lat === point.lat) {\n            var _node_docIDs;\n            const index = (_node_docIDs = node.docIDs) === null || _node_docIDs === void 0 ? void 0 : _node_docIDs.indexOf(docID);\n            if (index !== undefined && index > -1) {\n                var // Remove the docID from the array\n                _node_docIDs1;\n                (_node_docIDs1 = node.docIDs) === null || _node_docIDs1 === void 0 ? void 0 : _node_docIDs1.splice(index, 1);\n                if (node.docIDs == null || node.docIDs.length === 0) {\n                    // If the node doesn't have any more docIDs, remove the node\n                    if (parentNode != null) {\n                        if (direction === 'left') {\n                            parentNode.left = node.left !== null ? node.left : node.right;\n                        } else if (direction === 'right') {\n                            parentNode.right = node.right !== null ? node.right : node.left;\n                        }\n                    } else {\n                        // If the node to be removed is the root\n                        tree.root = node.left !== null ? node.left : node.right;\n                    }\n                }\n                return;\n            }\n        }\n        const axis = depth % K;\n        parentNode = node;\n        // Compare by longitude\n        if (axis === 0) {\n            if (point.lon < node.point.lon) {\n                node = node === null || node === void 0 ? void 0 : node.left;\n                direction = 'left';\n            } else {\n                node = node === null || node === void 0 ? void 0 : node.right;\n                direction = 'right';\n            }\n        // Compare by latitude\n        } else {\n            if (point.lat < node.point.lat) {\n                node = node === null || node === void 0 ? void 0 : node.left;\n                direction = 'left';\n            } else {\n                node = node === null || node === void 0 ? void 0 : node.right;\n                direction = 'right';\n            }\n        }\n        depth++;\n    }\n}\nexport function getDocIDsByCoordinates(tree, point) {\n    let node = tree.root;\n    let depth = 0;\n    while(node !== null){\n        if (node.point.lon === point.lon && node.point.lat === point.lat) {\n            // prettier-ignore\n            return node.docIDs ?? null;\n        }\n        const axis = depth % K;\n        // Compare by longitude\n        if (axis === 0) {\n            if (point.lon < node.point.lon) {\n                node = node.left;\n            } else {\n                node = node.right;\n            }\n        // Compare by latitude\n        } else {\n            if (point.lat < node.point.lat) {\n                node = node.left;\n            } else {\n                node = node.right;\n            }\n        }\n        depth++;\n    }\n    return null;\n}\nexport function searchByRadius(node, center, radius, inclusive = true, sort = 'asc', highPrecision = false) {\n    const distanceFn = highPrecision ? vincentyDistance : haversineDistance;\n    const stack = [\n        {\n            node,\n            depth: 0\n        }\n    ];\n    const result = [];\n    while(stack.length > 0){\n        const { node , depth  } = stack.pop();\n        if (node === null) continue;\n        const dist = distanceFn(center, node.point);\n        if (inclusive ? dist <= radius : dist > radius) {\n            result.push({\n                point: node.point,\n                docIDs: node.docIDs ?? []\n            });\n        }\n        if (node.left != null) {\n            stack.push({\n                node: node.left,\n                depth: depth + 1\n            });\n        }\n        if (node.right != null) {\n            stack.push({\n                node: node.right,\n                depth: depth + 1\n            });\n        }\n    }\n    if (sort) {\n        result.sort((a, b)=>{\n            const distA = distanceFn(center, a.point);\n            const distB = distanceFn(center, b.point);\n            return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA;\n        });\n    }\n    return result;\n}\nexport function searchByPolygon(root, polygon, inclusive = true, sort = null, highPrecision = false) {\n    const stack = [\n        {\n            node: root,\n            depth: 0\n        }\n    ];\n    const result = [];\n    while(stack.length > 0){\n        const task = stack.pop();\n        if (task == null || task.node == null) continue;\n        const { node , depth  } = task;\n        const nextDepth = depth + 1;\n        if (node.left != null) {\n            stack.push({\n                node: node.left,\n                depth: nextDepth\n            });\n        }\n        if (node.right != null) {\n            stack.push({\n                node: node.right,\n                depth: nextDepth\n            });\n        }\n        const isInsidePolygon = isPointInPolygon(polygon, node.point);\n        if (isInsidePolygon && inclusive) {\n            result.push({\n                point: node.point,\n                docIDs: node.docIDs ?? []\n            });\n        } else if (!isInsidePolygon && !inclusive) {\n            result.push({\n                point: node.point,\n                docIDs: node.docIDs ?? []\n            });\n        }\n    }\n    const centroid = calculatePolygonCentroid(polygon);\n    if (sort) {\n        const sortFn = highPrecision ? vincentyDistance : haversineDistance;\n        result.sort((a, b)=>{\n            const distA = sortFn(centroid, a.point);\n            const distB = sortFn(centroid, b.point);\n            return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA;\n        });\n    }\n    return result;\n}\nfunction calculatePolygonCentroid(polygon) {\n    let totalArea = 0;\n    let centroidX = 0;\n    let centroidY = 0;\n    const polygonLength = polygon.length;\n    for(let i = 0, j = polygonLength - 1; i < polygonLength; j = i++){\n        const xi = polygon[i].lon;\n        const yi = polygon[i].lat;\n        const xj = polygon[j].lon;\n        const yj = polygon[j].lat;\n        const areaSegment = xi * yj - xj * yi;\n        totalArea += areaSegment;\n        centroidX += (xi + xj) * areaSegment;\n        centroidY += (yi + yj) * areaSegment;\n    }\n    totalArea /= 2;\n    const centroidCoordinate = 6 * totalArea;\n    centroidX /= centroidCoordinate;\n    centroidY /= centroidCoordinate;\n    return {\n        lon: centroidX,\n        lat: centroidY\n    };\n}\nfunction isPointInPolygon(polygon, point) {\n    let isInside = false;\n    const x = point.lon;\n    const y = point.lat;\n    const polygonLength = polygon.length;\n    for(let i = 0, j = polygonLength - 1; i < polygonLength; j = i++){\n        const xi = polygon[i].lon;\n        const yi = polygon[i].lat;\n        const xj = polygon[j].lon;\n        const yj = polygon[j].lat;\n        const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\nfunction haversineDistance(coord1, coord2) {\n    const P = Math.PI / 180;\n    const lat1 = coord1.lat * P;\n    const lat2 = coord2.lat * P;\n    const deltaLat = (coord2.lat - coord1.lat) * P;\n    const deltaLon = (coord2.lon - coord1.lon) * P;\n    const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return EARTH_RADIUS * c;\n}\nfunction vincentyDistance(coord1, coord2) {\n    // Constants for WGS 84 ellipsoidal Earth model (https://epsg.org/ellipsoid_7030/WGS-84.html)\n    // Semi-major axis of the Earth in meters\n    const a = 6378137;\n    // Flattening of the ellipsoid\n    const f = 1 / 298.257223563;\n    // Semi-minor axis\n    const b = (1 - f) * a;\n    // Convert degrees to radians for calculations\n    const P = Math.PI / 180;\n    const lat1 = coord1.lat * P;\n    const lat2 = coord2.lat * P;\n    const deltaLon = (coord2.lon - coord1.lon) * P;\n    // Reduced latitudes - account for flattening by transforming from geodetic to auxiliary latitude\n    const U1 = Math.atan((1 - f) * Math.tan(lat1));\n    const U2 = Math.atan((1 - f) * Math.tan(lat2));\n    const sinU1 = Math.sin(U1);\n    const cosU1 = Math.cos(U1);\n    const sinU2 = Math.sin(U2);\n    const cosU2 = Math.cos(U2);\n    // Initial approximation for the longitude difference between the two points\n    let lambda = deltaLon;\n    let prevLambda;\n    // Limit the iterations to ensure we don't get stuck in an infinite loop\n    let iterationLimit = 1000;\n    let sinAlpha;\n    let cos2Alpha;\n    let sinSigma;\n    let cosSigma;\n    let sigma;\n    // Refine the value of lambda (longitude difference)\n    do {\n        const sinLambda = Math.sin(lambda);\n        const cosLambda = Math.cos(lambda);\n        // Compute the trigonometric values required for Vincenty formulae\n        sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;\n        sigma = Math.atan2(sinSigma, cosSigma);\n        // Angular separation between the two points and the equator\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;\n        cos2Alpha = 1 - sinAlpha * sinAlpha;\n        const cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cos2Alpha;\n        // Compensation factor for the Earth's shape\n        const C = f / 16 * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));\n        // Store previous lambda to check for convergence\n        prevLambda = lambda;\n        // Refine the estimate of lambda using the Vincenty formula\n        lambda = deltaLon + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\n    }while (Math.abs(lambda - prevLambda) > 1e-12 && --iterationLimit > 0)\n    // Compute factors that depend on the shape of the Earth and angular distances\n    const u2 = cos2Alpha * (a * a - b * b) / (b * b);\n    const A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));\n    const B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));\n    // Compute the correction factor for the ellipsoidal shape of the Earth\n    const deltaSigma = B * sinSigma * (cosSigma - 2 * sinU1 * sinU2 / cos2Alpha + B / 4 * (cosSigma * (-1 + 2 * sinSigma * sinSigma) - B / 6 * sigma * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * sigma * sigma)));\n    // Final calculation of distance using Vincenty formula\n    const s = b * A * (sigma - deltaSigma);\n    return s;\n}\n\n//# sourceMappingURL=bkd.js.map","import { createError } from '../errors.js';\nimport { create as avlCreate, find as avlFind, greaterThan as avlGreaterThan, insert as avlInsert, lessThan as avlLessThan, rangeSearch as avlRangeSearch, removeDocument as avlRemoveDocument } from '../trees/avl.js';\nimport { create as flatCreate, filter as flatFilter, filterArr as flatFilterArr, insert as flatInsert, removeDocument as flatRemoveDocument } from '../trees/flat.js';\nimport { create as radixCreate, find as radixFind, insert as radixInsert, removeDocumentByWord as radixRemoveDocument } from '../trees/radix.js';\nimport { create as bkdCreate, insert as bkdInsert, removeDocByID as bkdRemoveDocByID, searchByRadius, searchByPolygon } from '../trees/bkd.js';\nimport { convertDistanceToMeters, intersect, safeArrayPush, getOwnProperty } from '../utils.js';\nimport { BM25 } from './algorithms.js';\nimport { getMagnitude } from './cosine-similarity.js';\nimport { getInnerType, getVectorSize, isArrayType, isVectorType } from './defaults.js';\nimport { getInternalDocumentId } from './internal-document-id-store.js';\nexport async function insertDocumentScoreParameters(index, prop, id, tokens, docsCount) {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n    index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount;\n    index.fieldLengths[prop][internalId] = tokens.length;\n    index.frequencies[prop][internalId] = {};\n}\nexport async function insertTokenScoreParameters(index, prop, id, tokens, token) {\n    let tokenFrequency = 0;\n    for (const t of tokens){\n        if (t === token) {\n            tokenFrequency++;\n        }\n    }\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n    const tf = tokenFrequency / tokens.length;\n    index.frequencies[prop][internalId][token] = tf;\n    if (!(token in index.tokenOccurrences[prop])) {\n        index.tokenOccurrences[prop][token] = 0;\n    }\n    // increase a token counter that may not yet exist\n    index.tokenOccurrences[prop][token] = (index.tokenOccurrences[prop][token] ?? 0) + 1;\n}\nexport async function removeDocumentScoreParameters(index, prop, id, docsCount) {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n    index.avgFieldLength[prop] = (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]) / (docsCount - 1);\n    index.fieldLengths[prop][internalId] = undefined;\n    index.frequencies[prop][internalId] = undefined;\n}\nexport async function removeTokenScoreParameters(index, prop, token) {\n    index.tokenOccurrences[prop][token]--;\n}\nexport async function calculateResultScores(context, index, prop, term, ids) {\n    const documentIDs = Array.from(ids);\n    // Exact fields for TF-IDF\n    const avgFieldLength = index.avgFieldLength[prop];\n    const fieldLengths = index.fieldLengths[prop];\n    const oramaOccurrences = index.tokenOccurrences[prop];\n    const oramaFrequencies = index.frequencies[prop];\n    // oramaOccurrences[term] can be undefined, 0, string, or { [k: string]: number }\n    const termOccurrences = typeof oramaOccurrences[term] === 'number' ? oramaOccurrences[term] ?? 0 : 0;\n    const scoreList = [];\n    // Calculate TF-IDF value for each term, in each document, for each index.\n    const documentIDsLength = documentIDs.length;\n    for(let k = 0; k < documentIDsLength; k++){\n        var _oramaFrequencies_internalId;\n        const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, documentIDs[k]);\n        const tf = (oramaFrequencies === null || oramaFrequencies === void 0 ? void 0 : (_oramaFrequencies_internalId = oramaFrequencies[internalId]) === null || _oramaFrequencies_internalId === void 0 ? void 0 : _oramaFrequencies_internalId[term]) ?? 0;\n        const bm25 = BM25(tf, termOccurrences, context.docsCount, fieldLengths[internalId], avgFieldLength, context.params.relevance);\n        scoreList.push([\n            internalId,\n            bm25\n        ]);\n    }\n    return scoreList;\n}\nexport async function create(orama, sharedInternalDocumentStore, schema, index, prefix = '') {\n    if (!index) {\n        index = {\n            sharedInternalDocumentStore,\n            indexes: {},\n            vectorIndexes: {},\n            searchableProperties: [],\n            searchablePropertiesWithTypes: {},\n            frequencies: {},\n            tokenOccurrences: {},\n            avgFieldLength: {},\n            fieldLengths: {}\n        };\n    }\n    for (const [prop, type] of Object.entries(schema)){\n        const path = `${prefix}${prefix ? '.' : ''}${prop}`;\n        if (typeof type === 'object' && !Array.isArray(type)) {\n            // Nested\n            create(orama, sharedInternalDocumentStore, type, index, path);\n            continue;\n        }\n        if (isVectorType(type)) {\n            index.searchableProperties.push(path);\n            index.searchablePropertiesWithTypes[path] = type;\n            index.vectorIndexes[path] = {\n                size: getVectorSize(type),\n                vectors: {}\n            };\n        } else {\n            const isArray = /\\[/.test(type);\n            switch(type){\n                case 'boolean':\n                case 'boolean[]':\n                    index.indexes[path] = {\n                        type: 'Bool',\n                        node: {\n                            true: [],\n                            false: []\n                        },\n                        isArray\n                    };\n                    break;\n                case 'number':\n                case 'number[]':\n                    index.indexes[path] = {\n                        type: 'AVL',\n                        node: avlCreate(0, []),\n                        isArray\n                    };\n                    break;\n                case 'string':\n                case 'string[]':\n                    index.indexes[path] = {\n                        type: 'Radix',\n                        node: radixCreate(),\n                        isArray\n                    };\n                    index.avgFieldLength[path] = 0;\n                    index.frequencies[path] = {};\n                    index.tokenOccurrences[path] = {};\n                    index.fieldLengths[path] = {};\n                    break;\n                case 'enum':\n                case 'enum[]':\n                    index.indexes[path] = {\n                        type: 'Flat',\n                        node: flatCreate(),\n                        isArray\n                    };\n                    break;\n                case 'geopoint':\n                    index.indexes[path] = {\n                        type: 'BKD',\n                        node: bkdCreate(),\n                        isArray\n                    };\n                    break;\n                default:\n                    throw createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path);\n            }\n            index.searchableProperties.push(path);\n            index.searchablePropertiesWithTypes[path] = type;\n        }\n    }\n    return index;\n}\nasync function insertScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n    const { type , node  } = index.indexes[prop];\n    switch(type){\n        case 'Bool':\n            {\n                node[value ? 'true' : 'false'].push(internalId);\n                break;\n            }\n        case 'AVL':\n            {\n                avlInsert(node, value, [\n                    internalId\n                ]);\n                break;\n            }\n        case 'Radix':\n            {\n                const tokens = await tokenizer.tokenize(value, language, prop);\n                await implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount);\n                for (const token of tokens){\n                    await implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token);\n                    radixInsert(node, token, internalId);\n                }\n                break;\n            }\n        case 'Flat':\n            {\n                flatInsert(node, value, internalId);\n                break;\n            }\n        case 'BKD':\n            {\n                bkdInsert(node, value, [\n                    internalId\n                ]);\n                break;\n            }\n    }\n}\nexport async function insert(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n    if (isVectorType(schemaType)) {\n        return insertVector(index, prop, value, id);\n    }\n    if (!isArrayType(schemaType)) {\n        return insertScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount);\n    }\n    const innerSchemaType = getInnerType(schemaType);\n    const elements = value;\n    const elementsLength = elements.length;\n    for(let i = 0; i < elementsLength; i++){\n        await insertScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount);\n    }\n}\nfunction insertVector(index, prop, value, id) {\n    if (!(value instanceof Float32Array)) {\n        value = new Float32Array(value);\n    }\n    const size = index.vectorIndexes[prop].size;\n    const magnitude = getMagnitude(value, size);\n    index.vectorIndexes[prop].vectors[id] = [\n        magnitude,\n        value\n    ];\n}\nasync function removeScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n    if (isVectorType(schemaType)) {\n        delete index.vectorIndexes[prop].vectors[id];\n        return true;\n    }\n    const { type , node  } = index.indexes[prop];\n    switch(type){\n        case 'AVL':\n            {\n                avlRemoveDocument(node, internalId, value);\n                return true;\n            }\n        case 'Bool':\n            {\n                const booleanKey = value ? 'true' : 'false';\n                const position = node[booleanKey].indexOf(internalId);\n                node[value ? 'true' : 'false'].splice(position, 1);\n                return true;\n            }\n        case 'Radix':\n            {\n                const tokens = await tokenizer.tokenize(value, language, prop);\n                await implementation.removeDocumentScoreParameters(index, prop, id, docsCount);\n                for (const token of tokens){\n                    await implementation.removeTokenScoreParameters(index, prop, token);\n                    radixRemoveDocument(node, token, internalId);\n                }\n                return true;\n            }\n        case 'Flat':\n            {\n                flatRemoveDocument(node, internalId, value);\n                return true;\n            }\n        case 'BKD':\n            {\n                bkdRemoveDocByID(node, value, internalId);\n                return false;\n            }\n    }\n}\nexport async function remove(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n    if (!isArrayType(schemaType)) {\n        return removeScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount);\n    }\n    const innerSchemaType = getInnerType(schemaType);\n    const elements = value;\n    const elementsLength = elements.length;\n    for(let i = 0; i < elementsLength; i++){\n        await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount);\n    }\n    return true;\n}\nexport async function search(context, index, prop, term) {\n    if (!(prop in index.tokenOccurrences)) {\n        return [];\n    }\n    const { node , type  } = index.indexes[prop];\n    if (type !== 'Radix') {\n        throw createError('WRONG_SEARCH_PROPERTY_TYPE', prop);\n    }\n    const { exact , tolerance  } = context.params;\n    const searchResult = radixFind(node, {\n        term,\n        exact,\n        tolerance\n    });\n    const ids = new Set();\n    for(const key in searchResult){\n        //skip keys inherited from prototype\n        const ownProperty = getOwnProperty(searchResult, key);\n        if (!ownProperty) continue;\n        for (const id of searchResult[key]){\n            ids.add(id);\n        }\n    }\n    return context.index.calculateResultScores(context, index, prop, term, Array.from(ids));\n}\nexport async function searchByWhereClause(context, index, filters) {\n    const filterKeys = Object.keys(filters);\n    const filtersMap = filterKeys.reduce((acc, key)=>({\n            [key]: [],\n            ...acc\n        }), {});\n    for (const param of filterKeys){\n        const operation = filters[param];\n        if (typeof index.indexes[param] === 'undefined') {\n            throw createError('UNKNOWN_FILTER_PROPERTY', param);\n        }\n        const { node , type , isArray  } = index.indexes[param];\n        if (type === 'Bool') {\n            const idx = node;\n            const filteredIDs = idx[operation.toString()];\n            safeArrayPush(filtersMap[param], filteredIDs);\n            continue;\n        }\n        if (type === 'BKD') {\n            let reqOperation;\n            if ('radius' in operation) {\n                reqOperation = 'radius';\n            } else if ('polygon' in operation) {\n                reqOperation = 'polygon';\n            } else {\n                throw new Error(`Invalid operation ${operation}`);\n            }\n            if (reqOperation === 'radius') {\n                const { value , coordinates , unit ='m' , inside =true , highPrecision =false  } = operation[reqOperation];\n                const distanceInMeters = convertDistanceToMeters(value, unit);\n                const ids = searchByRadius(node.root, coordinates, distanceInMeters, inside, undefined, highPrecision);\n                // @todo: convert this into a for loop\n                safeArrayPush(filtersMap[param], ids.map(({ docIDs  })=>docIDs).flat());\n            } else {\n                const { coordinates , inside =true , highPrecision =false  } = operation[reqOperation];\n                const ids = searchByPolygon(node.root, coordinates, inside, undefined, highPrecision);\n                // @todo: convert this into a for loop\n                safeArrayPush(filtersMap[param], ids.map(({ docIDs  })=>docIDs).flat());\n            }\n            continue;\n        }\n        if (type === 'Radix' && (typeof operation === 'string' || Array.isArray(operation))) {\n            for (const raw of [\n                operation\n            ].flat()){\n                const term = await context.tokenizer.tokenize(raw, context.language, param);\n                for (const t of term){\n                    const filteredIDsResults = radixFind(node, {\n                        term: t,\n                        exact: true\n                    });\n                    safeArrayPush(filtersMap[param], Object.values(filteredIDsResults).flat());\n                }\n            }\n            continue;\n        }\n        const operationKeys = Object.keys(operation);\n        if (operationKeys.length > 1) {\n            throw createError('INVALID_FILTER_OPERATION', operationKeys.length);\n        }\n        if (type === 'Flat') {\n            if (isArray) {\n                safeArrayPush(filtersMap[param], flatFilterArr(node, operation));\n            } else {\n                safeArrayPush(filtersMap[param], flatFilter(node, operation));\n            }\n            continue;\n        }\n        if (type === 'AVL') {\n            const operationOpt = operationKeys[0];\n            const operationValue = operation[operationOpt];\n            let filteredIDs = [];\n            switch(operationOpt){\n                case 'gt':\n                    {\n                        filteredIDs = avlGreaterThan(node, operationValue, false);\n                        break;\n                    }\n                case 'gte':\n                    {\n                        filteredIDs = avlGreaterThan(node, operationValue, true);\n                        break;\n                    }\n                case 'lt':\n                    {\n                        filteredIDs = avlLessThan(node, operationValue, false);\n                        break;\n                    }\n                case 'lte':\n                    {\n                        filteredIDs = avlLessThan(node, operationValue, true);\n                        break;\n                    }\n                case 'eq':\n                    {\n                        filteredIDs = avlFind(node, operationValue) ?? [];\n                        break;\n                    }\n                case 'between':\n                    {\n                        const [min, max] = operationValue;\n                        filteredIDs = avlRangeSearch(node, min, max);\n                        break;\n                    }\n            }\n            safeArrayPush(filtersMap[param], filteredIDs);\n        }\n    }\n    // AND operation: calculate the intersection between all the IDs in filterMap\n    const result = intersect(Object.values(filtersMap));\n    return result;\n}\nexport async function getSearchableProperties(index) {\n    return index.searchableProperties;\n}\nexport async function getSearchablePropertiesWithTypes(index) {\n    return index.searchablePropertiesWithTypes;\n}\nfunction loadRadixNode(node) {\n    const convertedNode = radixCreate(node.e, node.s, node.k);\n    convertedNode.d = node.d;\n    convertedNode.w = node.w;\n    for (const childrenKey of Object.keys(node.c)){\n        convertedNode.c[childrenKey] = loadRadixNode(node.c[childrenKey]);\n    }\n    return convertedNode;\n}\nfunction loadFlatNode(node) {\n    return {\n        numberToDocumentId: new Map(node)\n    };\n}\nfunction saveFlatNode(node) {\n    return Array.from(node.numberToDocumentId.entries());\n}\nexport async function load(sharedInternalDocumentStore, raw) {\n    const { indexes: rawIndexes , vectorIndexes: rawVectorIndexes , searchableProperties , searchablePropertiesWithTypes , frequencies , tokenOccurrences , avgFieldLength , fieldLengths  } = raw;\n    const indexes = {};\n    const vectorIndexes = {};\n    for (const prop of Object.keys(rawIndexes)){\n        const { node , type , isArray  } = rawIndexes[prop];\n        switch(type){\n            case 'Radix':\n                indexes[prop] = {\n                    type: 'Radix',\n                    node: loadRadixNode(node),\n                    isArray\n                };\n                break;\n            case 'Flat':\n                indexes[prop] = {\n                    type: 'Flat',\n                    node: loadFlatNode(node),\n                    isArray\n                };\n                break;\n            default:\n                indexes[prop] = rawIndexes[prop];\n        }\n    }\n    for (const idx of Object.keys(rawVectorIndexes)){\n        const vectors = rawVectorIndexes[idx].vectors;\n        for(const vec in vectors){\n            vectors[vec] = [\n                vectors[vec][0],\n                new Float32Array(vectors[vec][1])\n            ];\n        }\n        vectorIndexes[idx] = {\n            size: rawVectorIndexes[idx].size,\n            vectors\n        };\n    }\n    return {\n        sharedInternalDocumentStore,\n        indexes,\n        vectorIndexes,\n        searchableProperties,\n        searchablePropertiesWithTypes,\n        frequencies,\n        tokenOccurrences,\n        avgFieldLength,\n        fieldLengths\n    };\n}\nexport async function save(index) {\n    const { indexes , vectorIndexes , searchableProperties , searchablePropertiesWithTypes , frequencies , tokenOccurrences , avgFieldLength , fieldLengths  } = index;\n    const vectorIndexesAsArrays = {};\n    for (const idx of Object.keys(vectorIndexes)){\n        const vectors = vectorIndexes[idx].vectors;\n        for(const vec in vectors){\n            vectors[vec] = [\n                vectors[vec][0],\n                Array.from(vectors[vec][1])\n            ];\n        }\n        vectorIndexesAsArrays[idx] = {\n            size: vectorIndexes[idx].size,\n            vectors\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const savedIndexes = {};\n    for (const name of Object.keys(indexes)){\n        const { type , node , isArray  } = indexes[name];\n        if (type !== 'Flat') {\n            savedIndexes[name] = indexes[name];\n            continue;\n        }\n        savedIndexes[name] = {\n            type: 'Flat',\n            node: saveFlatNode(node),\n            isArray\n        };\n    }\n    return {\n        indexes: savedIndexes,\n        vectorIndexes: vectorIndexesAsArrays,\n        searchableProperties,\n        searchablePropertiesWithTypes,\n        frequencies,\n        tokenOccurrences,\n        avgFieldLength,\n        fieldLengths\n    };\n}\nexport async function createIndex() {\n    return {\n        create,\n        insert,\n        remove,\n        insertDocumentScoreParameters,\n        insertTokenScoreParameters,\n        removeDocumentScoreParameters,\n        removeTokenScoreParameters,\n        calculateResultScores,\n        search,\n        searchByWhereClause,\n        getSearchableProperties,\n        getSearchablePropertiesWithTypes,\n        load,\n        save\n    };\n}\n\n//# sourceMappingURL=index.js.map","import { createError } from '../errors.js';\nimport { isVectorType } from './defaults.js';\nimport { getInternalDocumentId } from './internal-document-id-store.js';\nimport { safeArrayPush } from '../utils.js';\nfunction innerCreate(orama, sharedInternalDocumentStore, schema, sortableDeniedProperties, prefix) {\n    const sorter = {\n        language: orama.tokenizer.language,\n        sharedInternalDocumentStore,\n        enabled: true,\n        isSorted: true,\n        sortableProperties: [],\n        sortablePropertiesWithTypes: {},\n        sorts: {}\n    };\n    for (const [prop, type] of Object.entries(schema)){\n        const path = `${prefix}${prefix ? '.' : ''}${prop}`;\n        if (sortableDeniedProperties.includes(path)) {\n            continue;\n        }\n        if (typeof type === 'object' && !Array.isArray(type)) {\n            // Nested\n            const ret = innerCreate(orama, sharedInternalDocumentStore, type, sortableDeniedProperties, path);\n            safeArrayPush(sorter.sortableProperties, ret.sortableProperties);\n            sorter.sorts = {\n                ...sorter.sorts,\n                ...ret.sorts\n            };\n            sorter.sortablePropertiesWithTypes = {\n                ...sorter.sortablePropertiesWithTypes,\n                ...ret.sortablePropertiesWithTypes\n            };\n            continue;\n        }\n        if (!isVectorType(type)) {\n            switch(type){\n                case 'boolean':\n                case 'number':\n                case 'string':\n                    sorter.sortableProperties.push(path);\n                    sorter.sortablePropertiesWithTypes[path] = type;\n                    sorter.sorts[path] = {\n                        docs: new Map(),\n                        orderedDocsToRemove: new Map(),\n                        orderedDocs: [],\n                        type: type\n                    };\n                    break;\n                case 'geopoint':\n                case 'enum':\n                    continue;\n                case 'enum[]':\n                case 'boolean[]':\n                case 'number[]':\n                case 'string[]':\n                    continue;\n                default:\n                    throw createError('INVALID_SORT_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path);\n            }\n        }\n    }\n    return sorter;\n}\nasync function create(orama, sharedInternalDocumentStore, schema, config) {\n    const isSortEnabled = (config === null || config === void 0 ? void 0 : config.enabled) !== false;\n    if (!isSortEnabled) {\n        return {\n            disabled: true\n        };\n    }\n    return innerCreate(orama, sharedInternalDocumentStore, schema, (config || {}).unsortableProperties || [], '');\n}\nasync function insert(sorter, prop, id, value) {\n    if (!sorter.enabled) {\n        return;\n    }\n    sorter.isSorted = false;\n    const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id);\n    const s = sorter.sorts[prop];\n    s.docs.set(internalId, s.orderedDocs.length);\n    s.orderedDocs.push([\n        internalId,\n        value\n    ]);\n}\nfunction ensureIsSorted(sorter) {\n    if (sorter.isSorted) {\n        return;\n    }\n    if (!sorter.enabled) {\n        return;\n    }\n    const properties = Object.keys(sorter.sorts);\n    for (const prop of properties){\n        ensurePropertyIsSorted(sorter, prop);\n    }\n    sorter.isSorted = true;\n}\nfunction stringSort(language, value, d) {\n    return value[1].localeCompare(d[1], language);\n}\nfunction numberSort(value, d) {\n    return value[1] - d[1];\n}\nfunction booleanSort(value, d) {\n    return d[1] ? -1 : 1;\n}\nfunction ensurePropertyIsSorted(sorter, prop) {\n    const s = sorter.sorts[prop];\n    let predicate;\n    switch(s.type){\n        case 'string':\n            predicate = stringSort.bind(null, sorter.language);\n            break;\n        case 'number':\n            predicate = numberSort.bind(null);\n            break;\n        case 'boolean':\n            predicate = booleanSort.bind(null);\n            break;\n    }\n    s.orderedDocs.sort(predicate);\n    // Increment position for the greather documents\n    const orderedDocsLength = s.orderedDocs.length;\n    for(let i = 0; i < orderedDocsLength; i++){\n        const docId = s.orderedDocs[i][0];\n        s.docs.set(docId, i);\n    }\n}\nfunction ensureOrderedDocsAreDeleted(sorter) {\n    const properties = Object.keys(sorter.sorts);\n    for (const prop of properties){\n        ensureOrderedDocsAreDeletedByProperty(sorter, prop);\n    }\n}\nfunction ensureOrderedDocsAreDeletedByProperty(sorter, prop) {\n    const s = sorter.sorts[prop];\n    if (!s.orderedDocsToRemove.size) return;\n    s.orderedDocs = s.orderedDocs.filter((doc)=>!s.orderedDocsToRemove.has(doc[0]));\n    s.orderedDocsToRemove.clear();\n}\nasync function remove(sorter, prop, id) {\n    if (!sorter.enabled) {\n        return;\n    }\n    const s = sorter.sorts[prop];\n    const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id);\n    const index = s.docs.get(internalId);\n    if (!index) return;\n    s.docs.delete(internalId);\n    s.orderedDocsToRemove.set(internalId, true);\n}\nasync function sortBy(sorter, docIds, by) {\n    if (!sorter.enabled) {\n        throw createError('SORT_DISABLED');\n    }\n    const property = by.property;\n    const isDesc = by.order === 'DESC';\n    const s = sorter.sorts[property];\n    if (!s) {\n        throw createError('UNABLE_TO_SORT_ON_UNKNOWN_FIELD', property, sorter.sortableProperties.join(', '));\n    }\n    ensureOrderedDocsAreDeletedByProperty(sorter, property);\n    ensureIsSorted(sorter);\n    docIds.sort((a, b)=>{\n        // This sort algorithm works leveraging on\n        // that s.docs is a map of docId -> position\n        // If a document is not indexed, it will be not present in the map\n        const indexOfA = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, a[0]));\n        const indexOfB = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, b[0]));\n        const isAIndexed = typeof indexOfA !== 'undefined';\n        const isBIndexed = typeof indexOfB !== 'undefined';\n        if (!isAIndexed && !isBIndexed) {\n            return 0;\n        }\n        // unindexed documents are always at the end\n        if (!isAIndexed) {\n            return 1;\n        }\n        if (!isBIndexed) {\n            return -1;\n        }\n        return isDesc ? indexOfB - indexOfA : indexOfA - indexOfB;\n    });\n    return docIds;\n}\nasync function getSortableProperties(sorter) {\n    if (!sorter.enabled) {\n        return [];\n    }\n    return sorter.sortableProperties;\n}\nasync function getSortablePropertiesWithTypes(sorter) {\n    if (!sorter.enabled) {\n        return {};\n    }\n    return sorter.sortablePropertiesWithTypes;\n}\nexport async function load(sharedInternalDocumentStore, raw) {\n    const rawDocument = raw;\n    if (!rawDocument.enabled) {\n        return {\n            enabled: false\n        };\n    }\n    const sorts = Object.keys(rawDocument.sorts).reduce((acc, prop)=>{\n        const { docs , orderedDocs , type  } = rawDocument.sorts[prop];\n        acc[prop] = {\n            docs: new Map(Object.entries(docs).map(([k, v])=>[\n                    +k,\n                    v\n                ])),\n            orderedDocsToRemove: new Map(),\n            orderedDocs,\n            type\n        };\n        return acc;\n    }, {});\n    return {\n        sharedInternalDocumentStore,\n        language: rawDocument.language,\n        sortableProperties: rawDocument.sortableProperties,\n        sortablePropertiesWithTypes: rawDocument.sortablePropertiesWithTypes,\n        sorts,\n        enabled: true,\n        isSorted: rawDocument.isSorted\n    };\n}\nexport async function save(sorter) {\n    if (!sorter.enabled) {\n        return {\n            enabled: false\n        };\n    }\n    ensureOrderedDocsAreDeleted(sorter);\n    ensureIsSorted(sorter);\n    const sorts = Object.keys(sorter.sorts).reduce((acc, prop)=>{\n        const { docs , orderedDocs , type  } = sorter.sorts[prop];\n        acc[prop] = {\n            docs: Object.fromEntries(docs.entries()),\n            orderedDocs,\n            type\n        };\n        return acc;\n    }, {});\n    return {\n        language: sorter.language,\n        sortableProperties: sorter.sortableProperties,\n        sortablePropertiesWithTypes: sorter.sortablePropertiesWithTypes,\n        sorts,\n        enabled: sorter.enabled,\n        isSorted: sorter.isSorted\n    };\n}\nexport async function createSorter() {\n    return {\n        create,\n        insert,\n        remove,\n        save,\n        load,\n        sortBy,\n        getSortableProperties,\n        getSortablePropertiesWithTypes\n    };\n}\n\n//# sourceMappingURL=sorter.js.map","const DIACRITICS_CHARCODE_START = 192;\nconst DIACRITICS_CHARCODE_END = 383;\nconst CHARCODE_REPLACE_MAPPING = [\n    65,\n    65,\n    65,\n    65,\n    65,\n    65,\n    65,\n    67,\n    69,\n    69,\n    69,\n    69,\n    73,\n    73,\n    73,\n    73,\n    69,\n    78,\n    79,\n    79,\n    79,\n    79,\n    79,\n    null,\n    79,\n    85,\n    85,\n    85,\n    85,\n    89,\n    80,\n    115,\n    97,\n    97,\n    97,\n    97,\n    97,\n    97,\n    97,\n    99,\n    101,\n    101,\n    101,\n    101,\n    105,\n    105,\n    105,\n    105,\n    101,\n    110,\n    111,\n    111,\n    111,\n    111,\n    111,\n    null,\n    111,\n    117,\n    117,\n    117,\n    117,\n    121,\n    112,\n    121,\n    65,\n    97,\n    65,\n    97,\n    65,\n    97,\n    67,\n    99,\n    67,\n    99,\n    67,\n    99,\n    67,\n    99,\n    68,\n    100,\n    68,\n    100,\n    69,\n    101,\n    69,\n    101,\n    69,\n    101,\n    69,\n    101,\n    69,\n    101,\n    71,\n    103,\n    71,\n    103,\n    71,\n    103,\n    71,\n    103,\n    72,\n    104,\n    72,\n    104,\n    73,\n    105,\n    73,\n    105,\n    73,\n    105,\n    73,\n    105,\n    73,\n    105,\n    73,\n    105,\n    74,\n    106,\n    75,\n    107,\n    107,\n    76,\n    108,\n    76,\n    108,\n    76,\n    108,\n    76,\n    108,\n    76,\n    108,\n    78,\n    110,\n    78,\n    110,\n    78,\n    110,\n    110,\n    78,\n    110,\n    79,\n    111,\n    79,\n    111,\n    79,\n    111,\n    79,\n    111,\n    82,\n    114,\n    82,\n    114,\n    82,\n    114,\n    83,\n    115,\n    83,\n    115,\n    83,\n    115,\n    83,\n    115,\n    84,\n    116,\n    84,\n    116,\n    84,\n    116,\n    85,\n    117,\n    85,\n    117,\n    85,\n    117,\n    85,\n    117,\n    85,\n    117,\n    85,\n    117,\n    87,\n    119,\n    89,\n    121,\n    89,\n    90,\n    122,\n    90,\n    122,\n    90,\n    122,\n    115\n];\nfunction replaceChar(charCode) {\n    if (charCode < DIACRITICS_CHARCODE_START || charCode > DIACRITICS_CHARCODE_END) return charCode;\n    /* c8 ignore next  */ return CHARCODE_REPLACE_MAPPING[charCode - DIACRITICS_CHARCODE_START] || charCode;\n}\nexport function replaceDiacritics(str) {\n    const stringCharCode = [];\n    for(let idx = 0; idx < str.length; idx++){\n        stringCharCode[idx] = replaceChar(str.charCodeAt(idx));\n    }\n    return String.fromCharCode(...stringCharCode);\n}\n\n//# sourceMappingURL=diacritics.js.map","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\nconst step2List = {\n    ational: 'ate',\n    tional: 'tion',\n    enci: 'ence',\n    anci: 'ance',\n    izer: 'ize',\n    bli: 'ble',\n    alli: 'al',\n    entli: 'ent',\n    eli: 'e',\n    ousli: 'ous',\n    ization: 'ize',\n    ation: 'ate',\n    ator: 'ate',\n    alism: 'al',\n    iveness: 'ive',\n    fulness: 'ful',\n    ousness: 'ous',\n    aliti: 'al',\n    iviti: 'ive',\n    biliti: 'ble',\n    logi: 'log'\n};\nconst step3List = {\n    icate: 'ic',\n    ative: '',\n    alize: 'al',\n    iciti: 'ic',\n    ical: 'ic',\n    ful: '',\n    ness: ''\n};\n// Consonant\nconst c = '[^aeiou]';\n// Vowel\nconst v = '[aeiouy]';\n// Consonant sequence\nconst C = c + '[^aeiouy]*';\n// Vowel sequence\nconst V = v + '[aeiou]*';\n// [C]VC... is m>0\nconst mgr0 = '^(' + C + ')?' + V + C;\n// [C]VC[V] is m=1\nconst meq1 = '^(' + C + ')?' + V + C + '(' + V + ')?$';\n// [C]VCVC... is m>1\nconst mgr1 = '^(' + C + ')?' + V + C + V + C;\n// vowel in stem\nconst s_v = '^(' + C + ')?' + v;\nexport function stemmer(w) {\n    let stem;\n    let suffix;\n    let re;\n    let re2;\n    let re3;\n    let re4;\n    if (w.length < 3) {\n        return w;\n    }\n    const firstch = w.substring(0, 1);\n    if (firstch == 'y') {\n        w = firstch.toUpperCase() + w.substring(1);\n    }\n    re = /^(.+?)(ss|i)es$/;\n    re2 = /^(.+?)([^s])s$/;\n    if (re.test(w)) {\n        w = w.replace(re, '$1$2');\n    } else if (re2.test(w)) {\n        w = w.replace(re2, '$1$2');\n    }\n    re = /^(.+?)eed$/;\n    re2 = /^(.+?)(ed|ing)$/;\n    if (re.test(w)) {\n        const fp = re.exec(w);\n        re = new RegExp(mgr0);\n        if (re.test(fp[1])) {\n            re = /.$/;\n            w = w.replace(re, '');\n        }\n    } else if (re2.test(w)) {\n        const fp = re2.exec(w);\n        stem = fp[1];\n        re2 = new RegExp(s_v);\n        if (re2.test(stem)) {\n            w = stem;\n            re2 = /(at|bl|iz)$/;\n            re3 = new RegExp('([^aeiouylsz])\\\\1$');\n            re4 = new RegExp('^' + C + v + '[^aeiouwxy]$');\n            if (re2.test(w)) {\n                w = w + 'e';\n            } else if (re3.test(w)) {\n                re = /.$/;\n                w = w.replace(re, '');\n            } else if (re4.test(w)) {\n                w = w + 'e';\n            }\n        }\n    }\n    re = /^(.+?)y$/;\n    if (re.test(w)) {\n        const fp = re.exec(w);\n        stem = fp === null || fp === void 0 ? void 0 : fp[1];\n        re = new RegExp(s_v);\n        if (stem && re.test(stem)) {\n            w = stem + 'i';\n        }\n    }\n    re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;\n    if (re.test(w)) {\n        const fp = re.exec(w);\n        stem = fp === null || fp === void 0 ? void 0 : fp[1];\n        suffix = fp === null || fp === void 0 ? void 0 : fp[2];\n        re = new RegExp(mgr0);\n        if (stem && re.test(stem)) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            w = stem + step2List[suffix];\n        }\n    }\n    re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;\n    if (re.test(w)) {\n        const fp = re.exec(w);\n        stem = fp === null || fp === void 0 ? void 0 : fp[1];\n        suffix = fp === null || fp === void 0 ? void 0 : fp[2];\n        re = new RegExp(mgr0);\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        if (stem && re.test(stem)) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            w = stem + step3List[suffix];\n        }\n    }\n    re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;\n    re2 = /^(.+?)(s|t)(ion)$/;\n    if (re.test(w)) {\n        const fp = re.exec(w);\n        stem = fp === null || fp === void 0 ? void 0 : fp[1];\n        re = new RegExp(mgr1);\n        if (stem && re.test(stem)) {\n            w = stem;\n        }\n    } else if (re2.test(w)) {\n        const fp = re2.exec(w);\n        stem = (fp === null || fp === void 0 ? void 0 : fp[1]) ?? '' + (fp === null || fp === void 0 ? void 0 : fp[2]) ?? '';\n        re2 = new RegExp(mgr1);\n        if (re2.test(stem)) {\n            w = stem;\n        }\n    }\n    re = /^(.+?)e$/;\n    if (re.test(w)) {\n        const fp = re.exec(w);\n        stem = fp === null || fp === void 0 ? void 0 : fp[1];\n        re = new RegExp(mgr1);\n        re2 = new RegExp(meq1);\n        re3 = new RegExp('^' + C + v + '[^aeiouwxy]$');\n        if (stem && (re.test(stem) || re2.test(stem) && !re3.test(stem))) {\n            w = stem;\n        }\n    }\n    re = /ll$/;\n    re2 = new RegExp(mgr1);\n    if (re.test(w) && re2.test(w)) {\n        re = /.$/;\n        w = w.replace(re, '');\n    }\n    if (firstch == 'y') {\n        w = firstch.toLowerCase() + w.substring(1);\n    }\n    return w;\n}\n\n//# sourceMappingURL=english-stemmer.js.map","import { createError } from '../../errors.js';\nimport { replaceDiacritics } from './diacritics.js';\nimport { SPLITTERS, SUPPORTED_LANGUAGES } from './languages.js';\nimport { stemmer as english } from './english-stemmer.js';\nfunction normalizeToken(prop, token) {\n    var _this_stopWords;\n    const key = `${this.language}:${prop}:${token}`;\n    if (this.normalizationCache.has(key)) {\n        return this.normalizationCache.get(key);\n    }\n    // Remove stopwords if enabled\n    if ((_this_stopWords = this.stopWords) === null || _this_stopWords === void 0 ? void 0 : _this_stopWords.includes(token)) {\n        this.normalizationCache.set(key, '');\n        return '';\n    }\n    // Apply stemming if enabled\n    if (this.stemmer && !this.stemmerSkipProperties.has(prop)) {\n        token = this.stemmer(token);\n    }\n    token = replaceDiacritics(token);\n    this.normalizationCache.set(key, token);\n    return token;\n}\n/* c8 ignore next 10 */ function trim(text) {\n    while(text[text.length - 1] === ''){\n        text.pop();\n    }\n    while(text[0] === ''){\n        text.shift();\n    }\n    return text;\n}\nfunction tokenize(input, language, prop) {\n    if (language && language !== this.language) {\n        throw createError('LANGUAGE_NOT_SUPPORTED', language);\n    }\n    /* c8 ignore next 3 */ if (typeof input !== 'string') {\n        return [\n            input\n        ];\n    }\n    let tokens;\n    if (prop && this.tokenizeSkipProperties.has(prop)) {\n        tokens = [\n            this.normalizeToken.bind(this, prop ?? '')(input)\n        ];\n    } else {\n        const splitRule = SPLITTERS[this.language];\n        tokens = input.toLowerCase().split(splitRule).map(this.normalizeToken.bind(this, prop ?? '')).filter(Boolean);\n    }\n    const trimTokens = trim(tokens);\n    if (!this.allowDuplicates) {\n        return Array.from(new Set(trimTokens));\n    }\n    return trimTokens;\n}\nexport async function createTokenizer(config = {}) {\n    if (!config.language) {\n        config.language = 'english';\n    } else if (!SUPPORTED_LANGUAGES.includes(config.language)) {\n        throw createError('LANGUAGE_NOT_SUPPORTED', config.language);\n    }\n    // Handle stemming - It is disabled by default\n    let stemmer;\n    if (config.stemming || config.stemmer && !('stemming' in config)) {\n        if (config.stemmer) {\n            if (typeof config.stemmer !== 'function') {\n                throw createError('INVALID_STEMMER_FUNCTION_TYPE');\n            }\n            stemmer = config.stemmer;\n        } else {\n            if (config.language === 'english') {\n                stemmer = english;\n            } else {\n                throw createError('MISSING_STEMMER', config.language);\n            }\n        }\n    }\n    // Handle stopwords\n    let stopWords;\n    if (config.stopWords !== false) {\n        stopWords = [];\n        if (Array.isArray(config.stopWords)) {\n            stopWords = config.stopWords;\n        } else if (typeof config.stopWords === 'function') {\n            stopWords = await config.stopWords(stopWords);\n        } else if (config.stopWords) {\n            throw createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY');\n        }\n        // Make sure stopWords is just an array of strings\n        if (!Array.isArray(stopWords)) {\n            throw createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY');\n        }\n        for (const s of stopWords){\n            if (typeof s !== 'string') {\n                throw createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY');\n            }\n        }\n    }\n    // Create the tokenizer\n    const tokenizer = {\n        tokenize,\n        language: config.language,\n        stemmer,\n        stemmerSkipProperties: new Set(config.stemmerSkipProperties ? [\n            config.stemmerSkipProperties\n        ].flat() : []),\n        tokenizeSkipProperties: new Set(config.tokenizeSkipProperties ? [\n            config.tokenizeSkipProperties\n        ].flat() : []),\n        stopWords,\n        allowDuplicates: Boolean(config.allowDuplicates),\n        normalizeToken,\n        normalizationCache: new Map()\n    };\n    tokenizer.tokenize = tokenize.bind(tokenizer);\n    tokenizer.normalizeToken = normalizeToken;\n    return tokenizer;\n}\n\n//# sourceMappingURL=index.js.map","import { formatElapsedTime, getDocumentIndexId, getDocumentProperties, validateSchema } from '../components/defaults.js';\nimport { createDocumentsStore } from '../components/documents-store.js';\nimport { AVAILABLE_PLUGIN_HOOKS, getAllPluginsByHook } from '../components/plugins.js';\nimport { FUNCTION_COMPONENTS, OBJECT_COMPONENTS } from '../components/hooks.js';\nimport { createIndex } from '../components/index.js';\nimport { createInternalDocumentIDStore } from '../components/internal-document-id-store.js';\nimport { createSorter } from '../components/sorter.js';\nimport { createTokenizer } from '../components/tokenizer/index.js';\nimport { createError } from '../errors.js';\nimport { uniqueId } from '../utils.js';\nfunction validateComponents(components) {\n    const defaultComponents = {\n        formatElapsedTime,\n        getDocumentIndexId,\n        getDocumentProperties,\n        validateSchema\n    };\n    for (const rawKey of FUNCTION_COMPONENTS){\n        const key = rawKey;\n        if (components[key]) {\n            if (typeof components[key] !== 'function') {\n                throw createError('COMPONENT_MUST_BE_FUNCTION', key);\n            }\n        } else {\n            // @ts-expect-error TSC is unable to resolve this\n            components[key] = defaultComponents[key];\n        }\n    }\n    for (const rawKey of Object.keys(components)){\n        if (!OBJECT_COMPONENTS.includes(rawKey) && !FUNCTION_COMPONENTS.includes(rawKey)) {\n            throw createError('UNSUPPORTED_COMPONENT', rawKey);\n        }\n    }\n}\nexport async function create({ schema , sort , language , components , id , plugins  }) {\n    if (!components) {\n        components = {};\n    }\n    if (!id) {\n        id = await uniqueId();\n    }\n    let tokenizer = components.tokenizer;\n    let index = components.index;\n    let documentsStore = components.documentsStore;\n    let sorter = components.sorter;\n    if (!tokenizer) {\n        // Use the default tokenizer\n        tokenizer = await createTokenizer({\n            language: language ?? 'english'\n        });\n    } else if (!tokenizer.tokenize) {\n        // If there is no tokenizer function, we assume this is a TokenizerConfig\n        tokenizer = await createTokenizer(tokenizer);\n    } else {\n        const customTokenizer = tokenizer;\n        tokenizer = customTokenizer;\n    }\n    if (components.tokenizer && language) {\n        // Accept language only if a tokenizer is not provided\n        throw createError('NO_LANGUAGE_WITH_CUSTOM_TOKENIZER');\n    }\n    const internalDocumentStore = createInternalDocumentIDStore();\n    index ||= await createIndex();\n    sorter ||= await createSorter();\n    documentsStore ||= await createDocumentsStore();\n    // Validate all other components\n    validateComponents(components);\n    // Assign only recognized components and hooks\n    const { getDocumentProperties , getDocumentIndexId , validateSchema , formatElapsedTime  } = components;\n    const orama = {\n        data: {},\n        caches: {},\n        schema,\n        tokenizer,\n        index,\n        sorter,\n        documentsStore,\n        internalDocumentIDStore: internalDocumentStore,\n        getDocumentProperties,\n        getDocumentIndexId,\n        validateSchema,\n        beforeInsert: [],\n        afterInsert: [],\n        beforeRemove: [],\n        afterRemove: [],\n        beforeUpdate: [],\n        afterUpdate: [],\n        beforeSearch: [],\n        afterSearch: [],\n        beforeInsertMultiple: [],\n        afterInsertMultiple: [],\n        beforeRemoveMultiple: [],\n        afterRemoveMultiple: [],\n        afterUpdateMultiple: [],\n        beforeUpdateMultiple: [],\n        formatElapsedTime,\n        id,\n        plugins\n    };\n    orama.data = {\n        index: await orama.index.create(orama, internalDocumentStore, schema),\n        docs: await orama.documentsStore.create(orama, internalDocumentStore),\n        sorting: await orama.sorter.create(orama, internalDocumentStore, schema, sort)\n    };\n    for (const hook of AVAILABLE_PLUGIN_HOOKS){\n        orama[hook] = (orama[hook] ?? []).concat(await getAllPluginsByHook(orama, hook));\n    }\n    return orama;\n}\n\n//# sourceMappingURL=create.js.map"],"names":["getMagnitude","vector","vectorLength","magnitude","i","Math","sqrt","findSimilarVectors","targetVector","vectors","length","threshold","targetMagnitude","similarVectors","vectorId","Object","entries","dotProduct","similarity","push","sort","a","b","async","formatElapsedTime","n","raw","Number","formatted","getDocumentIndexId","doc","id","validateSchema","schema","prop","type","value","lon","lat","Array","isArray","valueLength","isVectorType","vectorSize","getVectorSize","isArrayType","expectedType","getInnerType","subProp","IS_ARRAY_TYPE","string","number","boolean","enum","geopoint","INNER_TYPE","isGeoPointType","test","size","slice","isNaN","OBJECT_COMPONENTS","FUNCTION_COMPONENTS","runSingleHook","hooks","orama","hooksLength","runMultipleHook","docsOrIds","runAfterSearch","db","params","language","results","runBeforeSearch","createInternalDocumentIDStore","idToInternalId","Map","internalIdToId","save","load","store","internalDocumentIDStore","clear","set","getInternalDocumentId","internalId","get","currentId","toString","getDocumentIdFromInternalId","Error","create","_","sharedInternalDocumentStore","docs","count","getMultiple","ids","found","from","getAll","remove","rawDocument","AVAILABLE_PLUGIN_HOOKS","getAllPluginsByHook","hook","_orama_plugins","pluginsToRun","pluginsLength","plugins","plugin","error","console","rotateLeft","node","right","r","l","h","max","getHeight","rotateRight","left","rangeSearch","min","result","traverse","k","v","root","greaterThan","key","inclusive","lessThan","getNodeByKey","find","filter","operation","operationKeys","keys","operationType","numberToDocumentId","includes","filterArr","map","Node","constructor","subWord","end","this","s","e","c","d","w","toJSON","updateParent","parent","addDocument","docID","index","indexOf","splice","findAllWords","output","term","exact","tolerance","docIDs","abs","isBounded","Set","docIDsLength","add","character","getCommonPrefix","commonPrefix","len","word","docId","wordLength","currentCharacter","wordAtIndex","substring","rootChildCurrentChar","newNode","edgeLabel","edgeLabelLength","commonPrefixLength","edgeLabelAtCommonPrefix","newNodeChild","inbetweenNode","inbetweenNodeChild","wordAtCommonPrefix","_findLevenshtein","originalTolerance","startsWith","termLength","termSubstring","removeDocumentByWord","K","EARTH_RADIUS","searchByRadius","center","radius","highPrecision","distanceFn","vincentyDistance","haversineDistance","stack","depth","pop","dist","point","distA","distB","toLowerCase","searchByPolygon","polygon","task","nextDepth","isInsidePolygon","isPointInPolygon","centroid","totalArea","centroidX","centroidY","polygonLength","j","xi","yi","xj","yj","areaSegment","centroidCoordinate","calculatePolygonCentroid","sortFn","isInside","x","y","coord1","coord2","P","PI","lat1","lat2","deltaLat","deltaLon","sin","cos","atan2","f","U1","atan","tan","U2","sinU1","cosU1","sinU2","cosU2","prevLambda","sinAlpha","cos2Alpha","sinSigma","cosSigma","sigma","lambda","iterationLimit","sinLambda","cosLambda","cos2SigmaM","C","u2","B","insertDocumentScoreParameters","tokens","docsCount","avgFieldLength","fieldLengths","frequencies","insertTokenScoreParameters","token","tokenFrequency","t","tf","tokenOccurrences","removeDocumentScoreParameters","undefined","removeTokenScoreParameters","calculateResultScores","context","documentIDs","oramaOccurrences","oramaFrequencies","termOccurrences","scoreList","documentIDsLength","_oramaFrequencies_internalId","bm25","relevance","prefix","indexes","vectorIndexes","searchableProperties","searchablePropertiesWithTypes","path","true","false","insertScalar","implementation","schemaType","tokenizer","newValue","rootNode","insertNode","balanceFactor","tokenize","has","tree","newDocIDs","Float32Array","insertVector","elements","elementsLength","innerSchemaType","removeScalar","parentNode","minValueNode","minValueParent","childNode","deleteNode","position","_root_numberToDocumentId_get","_root_numberToDocumentId_get1","delete","direction","_node_docIDs","_node_docIDs1","search","searchResult","searchByWhereClause","filters","filterKeys","filtersMap","reduce","acc","param","filteredIDs","reqOperation","coordinates","unit","inside","distanceInMeters","flat","filteredIDsResults","values","operationOpt","operationValue","getSearchableProperties","getSearchablePropertiesWithTypes","loadRadixNode","convertedNode","childrenKey","loadFlatNode","saveFlatNode","rawIndexes","rawVectorIndexes","idx","vec","vectorIndexesAsArrays","savedIndexes","name","innerCreate","sortableDeniedProperties","sorter","enabled","isSorted","sortableProperties","sortablePropertiesWithTypes","sorts","orderedDocsToRemove","orderedDocs","ret","config","unsortableProperties","disabled","ensureIsSorted","properties","ensurePropertyIsSorted","stringSort","localeCompare","numberSort","booleanSort","predicate","bind","orderedDocsLength","ensureOrderedDocsAreDeletedByProperty","sortBy","docIds","by","property","isDesc","order","join","indexOfA","indexOfB","isAIndexed","isBIndexed","getSortableProperties","getSortablePropertiesWithTypes","ensureOrderedDocsAreDeleted","fromEntries","DIACRITICS_CHARCODE_START","DIACRITICS_CHARCODE_END","CHARCODE_REPLACE_MAPPING","step2List","ational","tional","enci","anci","izer","bli","alli","entli","eli","ousli","ization","ation","ator","alism","iveness","fulness","ousness","aliti","iviti","biliti","logi","step3List","icate","ative","alize","iciti","ical","ful","ness","V","mgr0","meq1","mgr1","s_v","stem","suffix","re","re2","re3","re4","firstch","toUpperCase","replace","fp","exec","RegExp","normalizeToken","_this_stopWords","normalizationCache","stopWords","stemmer","stemmerSkipProperties","str","stringCharCode","charCode","charCodeAt","String","fromCharCode","replaceDiacritics","input","tokenizeSkipProperties","splitRule","split","Boolean","trimTokens","text","shift","trim","allowDuplicates","createTokenizer","stemming","components","documentsStore","internalDocumentStore","insert","createIndex","createSorter","createDocumentsStore","defaultComponents","getDocumentProperties","rawKey","validateComponents","data","caches","beforeInsert","afterInsert","beforeRemove","afterRemove","beforeUpdate","afterUpdate","beforeSearch","afterSearch","beforeInsertMultiple","afterInsertMultiple","beforeRemoveMultiple","afterRemoveMultiple","afterUpdateMultiple","beforeUpdateMultiple","sorting","concat"],"sourceRoot":""}