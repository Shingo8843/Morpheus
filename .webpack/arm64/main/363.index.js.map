{"version":3,"file":"363.index.js","mappings":"6IAAO,MAAMA,EAAoB,CAC7B,YACA,QACA,iBACA,UAESC,EAAsB,CAC/B,iBACA,qBACA,wBACA,qBAGGC,eAAeC,EAAcC,EAAOC,EAAOC,EAAIC,GAClD,MAAMC,EAAcJ,EAAMK,OAC1B,IAAI,IAAIC,EAAI,EAAGA,EAAIF,EAAaE,UACtBN,EAAMM,GAAGL,EAAOC,EAAIC,EAElC,CACOL,eAAeS,EAAgBP,EAAOC,EAAOO,GAChD,MAAMJ,EAAcJ,EAAMK,OAC1B,IAAI,IAAIC,EAAI,EAAGA,EAAIF,EAAaE,UACtBN,EAAMM,GAAGL,EAAOO,EAE9B,CACOV,eAAeW,EAAeT,EAAOU,EAAIC,EAAQC,EAAUC,GAC9D,MAAMT,EAAcJ,EAAMK,OAC1B,IAAI,IAAIC,EAAI,EAAGA,EAAIF,EAAaE,UACtBN,EAAMM,GAAGI,EAAIC,EAAQC,EAAUC,EAE7C,CACOf,eAAegB,EAAgBd,EAAOU,EAAIC,EAAQC,GACrD,MAAMR,EAAcJ,EAAMK,OAC1B,IAAI,IAAIC,EAAI,EAAGA,EAAIF,EAAaE,UACtBN,EAAMM,GAAGI,EAAIC,EAAQC,EAEnC,C,iBCpCO,SAASG,IACZ,MAAO,CACHC,eAAgB,IAAIC,IACpBC,eAAgB,GAChBC,OACAC,OAER,CACO,SAASD,EAAKE,GACjB,MAAO,CACHH,eAAgBG,EAAMH,eAE9B,CACO,SAASE,EAAKnB,EAAOqB,GACxB,MAAM,eAAEJ,GAAoBI,EAC5BrB,EAAMsB,wBAAwBP,eAAeQ,QAC7CvB,EAAMsB,wBAAwBL,eAAiB,GAC/C,IAAI,IAAIZ,EAAI,EAAGA,EAAIY,EAAeb,OAAQC,IACtCL,EAAMsB,wBAAwBP,eAAeS,IAAIP,EAAeZ,GAAIA,EAAI,GACxEL,EAAMsB,wBAAwBL,eAAeQ,KAAKR,EAAeZ,GAEzE,CACO,SAASqB,EAAsBN,EAAOnB,GACzC,GAAkB,iBAAPA,EAAiB,CACxB,MAAM0B,EAAaP,EAAML,eAAea,IAAI3B,GAC5C,GAAI0B,EACA,OAAOA,EAEX,MAAME,EAAYT,EAAML,eAAee,KAAO,EAG9C,OAFAV,EAAML,eAAeS,IAAIvB,EAAI4B,GAC7BT,EAAMH,eAAeQ,KAAKxB,GACnB4B,CACX,CACA,OAAI5B,EAAKmB,EAAMH,eAAeb,OACnBsB,EAAsBN,EAAOnB,EAAG8B,YAEpC9B,CACX,CACO,SAAS+B,EAA4BZ,EAAOO,GAC/C,GAAIP,EAAMH,eAAeb,OAASuB,EAC9B,MAAM,IAAIM,MAAM,sBAAsBN,KAE1C,OAAOP,EAAMH,eAAeU,EAAa,EAC7C,C,6EC3CO,MAAMO,EAAcC,OAAO,oBACrBC,EAAYD,OAAO,kBCDhC,IAAIE,EAGJ,MAAMC,GAAuD,QAA9CD,EAAsBE,WAAWC,eAA6C,IAAxBH,OAAiC,EAASA,EAAoBI,cAAgB,SAAqBC,EAASC,GAC7KC,QAAQN,KAAK,cAAcK,EAAQE,SAASH,IAChD,EACO,SAASI,EAAe9C,GACO,iBAAvBA,EAAMkC,KACba,gBAAe,KACX/C,EAAMkC,QAAec,CAAS,IAElChD,EAAMkC,GAAe,GAErBlC,EAAMkC,GAAe,KACrBI,EAAK,wMAAyM,CAC1MO,KAAM,cAEV7C,EAAMkC,IAAgB,GACflC,EAAMkC,IAAgB,GAC7BlC,EAAMkC,IAEd,CACO,SAASe,EAAajD,GACO,iBAArBA,EAAMoC,KACbW,gBAAe,KACX/C,EAAMoC,QAAaY,CAAS,IAEhChD,EAAMoC,GAAa,GAEnBpC,EAAMoC,GAAa,KACnBE,EAAK,oMAAqM,CACtMO,KAAM,cAEV7C,EAAMoC,IAAc,GACbpC,EAAMoC,IAAc,GAC3BpC,EAAMoC,IAEd,C,qGClCOvC,eAAeqD,EAAOlD,EAAOC,EAAIU,EAAUwC,GAC9C,IAAIC,GAAS,EACb,MAAM,MAAEC,EAAM,KAAEC,GAAUtD,EAAMuD,KAC1BrD,QAAYF,EAAMwD,eAAe5B,IAAI0B,EAAMrD,GACjD,IAAKC,EACD,OAAO,EAEX,MAAMuD,GAAQ,QAA4BzD,EAAMsB,yBAAyB,QAAsBtB,EAAMsB,wBAAyBrB,IACxHyD,QAAkB1D,EAAMwD,eAAeG,MAAML,GAC9CH,SACK,QAAcnD,EAAM4D,aAAc5D,EAAOyD,GAEnD,MAAMI,QAA4B7D,EAAMqD,MAAMS,wBAAwBT,GAChEU,QAAqC/D,EAAMqD,MAAMW,iCAAiCX,GAClFY,QAAejE,EAAMkE,sBAAsBhE,EAAK2D,GACtD,IAAK,MAAMM,KAAQN,EAAoB,CACnC,IAAIO,EAAcC,EAA2BC,EAAeC,EAC5D,MAAMC,EAAQP,EAAOE,GAErB,QAAqB,IAAVK,EACP,SAEJ,MAAMC,EAAaV,EAA6BI,SACmC,QAA3EE,GAA6BD,EAAepE,EAAMqD,OAAOO,oBAAwD,IAA9BS,OAAuC,EAASA,EAA0BK,KAAKN,EAAcpE,EAAMuD,KAAKF,MAAOc,EAAMV,EAAOe,EAAOC,EAAY9D,EAAUX,EAAM2E,UAAWjB,UAC1P1D,EAAMqD,MAAMH,OAAOlD,EAAMqD,MAAOrD,EAAMuD,KAAKF,MAAOc,EAAMlE,EAAIuE,EAAOC,EAAY9D,EAAUX,EAAM2E,UAAWjB,KACjHN,GAAS,SAEqE,QAA1EmB,GAA4BD,EAAgBtE,EAAMqD,OAAOuB,mBAAsD,IAA7BL,OAAsC,EAASA,EAAyBG,KAAKJ,EAAetE,EAAMuD,KAAKF,MAAOc,EAAMV,EAAOe,EAAOC,EAAY9D,EAAUX,EAAM2E,UAAWjB,GACvQ,CACA,MAAMmB,QAA2B7E,EAAM8E,OAAOC,sBAAsB/E,EAAMuD,KAAKyB,SACzEC,QAAuBjF,EAAMkE,sBAAsBhE,EAAK2E,GAC9D,IAAK,MAAMV,KAAQU,OAEqB,IAAzBI,EAAed,UAGpBnE,EAAM8E,OAAO5B,OAAOlD,EAAMuD,KAAKyB,QAASb,EAAMlE,GAOxD,OALKkD,SACK,QAAcnD,EAAM4E,YAAa5E,EAAOyD,SAE5CzD,EAAMwD,eAAeN,OAAOlD,EAAMuD,KAAKD,KAAMrD,IACnD,OAAaD,GACNoD,CACX,CACOvD,eAAeqF,EAAelF,EAAOmF,EAAKC,EAAWzE,EAAUwC,GAClE,IAAIC,EAAS,EACRgC,IACDA,EAAY,KAEhB,MAAMC,EAAiBlC,EAAY,GAAKgC,EAAIG,KAAKrF,IAAK,QAA4BD,EAAMsB,yBAAyB,QAAsBtB,EAAMsB,wBAAyBrB,MA4BtK,OA3BKkD,SACK,QAAgBnD,EAAMuF,qBAAsBvF,EAAOqF,SAEvD,IAAIG,SAAQ,CAACC,EAASC,KACxB,IAAIrF,EAAI,EAkBRsF,YAjBA9F,eAAe+F,IACX,MAAMC,EAAQV,EAAIW,MAAMzF,EAAI+E,GAAY/E,EAAI,GAAK+E,GAEjD,GADA/E,KACKwF,EAAMzF,OACP,OAAOqF,IAEX,IAAK,MAAMvF,KAAO2F,EACd,UACc3C,EAAOlD,EAAOE,EAAKS,EAAUwC,IACnCC,GAER,CAAE,MAAO2C,GACLL,EAAOK,EACX,CAEJJ,WAAWC,EAAiB,EAChC,GAC4B,EAAE,IAE7BzC,SACK,QAAgBnD,EAAMgG,oBAAqBhG,EAAOqF,GAErDjC,CACX,C","sources":["webpack://morpheus/./node_modules/@orama/orama/dist/components/hooks.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/internal-document-id-store.js","webpack://morpheus/./node_modules/@orama/orama/dist/types.js","webpack://morpheus/./node_modules/@orama/orama/dist/components/sync-blocking-checker.js","webpack://morpheus/./node_modules/@orama/orama/dist/methods/remove.js"],"sourcesContent":["export const OBJECT_COMPONENTS = [\n    'tokenizer',\n    'index',\n    'documentsStore',\n    'sorter'\n];\nexport const FUNCTION_COMPONENTS = [\n    'validateSchema',\n    'getDocumentIndexId',\n    'getDocumentProperties',\n    'formatElapsedTime'\n];\nexport const SINGLE_OR_ARRAY_COMPONENTS = [];\nexport async function runSingleHook(hooks, orama, id, doc) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](orama, id, doc);\n    }\n}\nexport async function runMultipleHook(hooks, orama, docsOrIds) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](orama, docsOrIds);\n    }\n}\nexport async function runAfterSearch(hooks, db, params, language, results) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](db, params, language, results);\n    }\n}\nexport async function runBeforeSearch(hooks, db, params, language) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](db, params, language);\n    }\n}\n\n//# sourceMappingURL=hooks.js.map","export function createInternalDocumentIDStore() {\n    return {\n        idToInternalId: new Map(),\n        internalIdToId: [],\n        save,\n        load\n    };\n}\nexport function save(store) {\n    return {\n        internalIdToId: store.internalIdToId\n    };\n}\nexport function load(orama, raw) {\n    const { internalIdToId  } = raw;\n    orama.internalDocumentIDStore.idToInternalId.clear();\n    orama.internalDocumentIDStore.internalIdToId = [];\n    for(let i = 0; i < internalIdToId.length; i++){\n        orama.internalDocumentIDStore.idToInternalId.set(internalIdToId[i], i + 1);\n        orama.internalDocumentIDStore.internalIdToId.push(internalIdToId[i]);\n    }\n}\nexport function getInternalDocumentId(store, id) {\n    if (typeof id === 'string') {\n        const internalId = store.idToInternalId.get(id);\n        if (internalId) {\n            return internalId;\n        }\n        const currentId = store.idToInternalId.size + 1;\n        store.idToInternalId.set(id, currentId);\n        store.internalIdToId.push(id);\n        return currentId;\n    }\n    if (id > store.internalIdToId.length) {\n        return getInternalDocumentId(store, id.toString());\n    }\n    return id;\n}\nexport function getDocumentIdFromInternalId(store, internalId) {\n    if (store.internalIdToId.length < internalId) {\n        throw new Error(`Invalid internalId ${internalId}`);\n    }\n    return store.internalIdToId[internalId - 1];\n}\n\n//# sourceMappingURL=internal-document-id-store.js.map","export const kInsertions = Symbol('orama.insertions');\nexport const kRemovals = Symbol('orama.removals');\n\n//# sourceMappingURL=types.js.map","var _globalThis_process;\nimport { kInsertions, kRemovals } from '../types.js';\n// Web platforms don't have process. React-Native doesn't have process.emitWarning.\nconst warn = ((_globalThis_process = globalThis.process) === null || _globalThis_process === void 0 ? void 0 : _globalThis_process.emitWarning) ?? function emitWarning(message, options) {\n    console.warn(`[WARNING] [${options.code}] ${message}`);\n};\nexport function trackInsertion(orama) {\n    if (typeof orama[kInsertions] !== 'number') {\n        queueMicrotask(()=>{\n            orama[kInsertions] = undefined;\n        });\n        orama[kInsertions] = 0;\n    }\n    if (orama[kInsertions] > 1000) {\n        warn(\"Orama's insert operation is synchronous. Please avoid inserting a large number of document in a single operation in order not to block the main thread or, in alternative, please use insertMultiple.\", {\n            code: 'ORAMA0001'\n        });\n        orama[kInsertions] = -1;\n    } else if (orama[kInsertions] >= 0) {\n        orama[kInsertions]++;\n    }\n}\nexport function trackRemoval(orama) {\n    if (typeof orama[kRemovals] !== 'number') {\n        queueMicrotask(()=>{\n            orama[kRemovals] = undefined;\n        });\n        orama[kRemovals] = 0;\n    }\n    if (orama[kRemovals] > 1000) {\n        warn(\"Orama's remove operation is synchronous. Please avoid removing a large number of document in a single operation in order not to block the main thread, in alternative, please use updateMultiple.\", {\n            code: 'ORAMA0002'\n        });\n        orama[kRemovals] = -1;\n    } else if (orama[kRemovals] >= 0) {\n        orama[kRemovals]++;\n    }\n}\n\n//# sourceMappingURL=sync-blocking-checker.js.map","import { runMultipleHook, runSingleHook } from '../components/hooks.js';\nimport { getDocumentIdFromInternalId, getInternalDocumentId } from '../components/internal-document-id-store.js';\nimport { trackRemoval } from '../components/sync-blocking-checker.js';\nexport async function remove(orama, id, language, skipHooks) {\n    let result = true;\n    const { index , docs  } = orama.data;\n    const doc = await orama.documentsStore.get(docs, id);\n    if (!doc) {\n        return false;\n    }\n    const docId = getDocumentIdFromInternalId(orama.internalDocumentIDStore, getInternalDocumentId(orama.internalDocumentIDStore, id));\n    const docsCount = await orama.documentsStore.count(docs);\n    if (!skipHooks) {\n        await runSingleHook(orama.beforeRemove, orama, docId);\n    }\n    const indexableProperties = await orama.index.getSearchableProperties(index);\n    const indexablePropertiesWithTypes = await orama.index.getSearchablePropertiesWithTypes(index);\n    const values = await orama.getDocumentProperties(doc, indexableProperties);\n    for (const prop of indexableProperties){\n        var _orama_index, _orama_index_beforeRemove, _orama_index1, _orama_index_afterRemove;\n        const value = values[prop];\n        // The document doesn't contain the key\n        if (typeof value === 'undefined') {\n            continue;\n        }\n        const schemaType = indexablePropertiesWithTypes[prop];\n        await ((_orama_index_beforeRemove = (_orama_index = orama.index).beforeRemove) === null || _orama_index_beforeRemove === void 0 ? void 0 : _orama_index_beforeRemove.call(_orama_index, orama.data.index, prop, docId, value, schemaType, language, orama.tokenizer, docsCount));\n        if (!await orama.index.remove(orama.index, orama.data.index, prop, id, value, schemaType, language, orama.tokenizer, docsCount)) {\n            result = false;\n        }\n        await ((_orama_index_afterRemove = (_orama_index1 = orama.index).afterRemove) === null || _orama_index_afterRemove === void 0 ? void 0 : _orama_index_afterRemove.call(_orama_index1, orama.data.index, prop, docId, value, schemaType, language, orama.tokenizer, docsCount));\n    }\n    const sortableProperties = await orama.sorter.getSortableProperties(orama.data.sorting);\n    const sortableValues = await orama.getDocumentProperties(doc, sortableProperties);\n    for (const prop of sortableProperties){\n        // The document doesn't contain the key\n        if (typeof sortableValues[prop] === 'undefined') {\n            continue;\n        }\n        await orama.sorter.remove(orama.data.sorting, prop, id);\n    }\n    if (!skipHooks) {\n        await runSingleHook(orama.afterRemove, orama, docId);\n    }\n    await orama.documentsStore.remove(orama.data.docs, id);\n    trackRemoval(orama);\n    return result;\n}\nexport async function removeMultiple(orama, ids, batchSize, language, skipHooks) {\n    let result = 0;\n    if (!batchSize) {\n        batchSize = 1000;\n    }\n    const docIdsForHooks = skipHooks ? [] : ids.map((id)=>getDocumentIdFromInternalId(orama.internalDocumentIDStore, getInternalDocumentId(orama.internalDocumentIDStore, id)));\n    if (!skipHooks) {\n        await runMultipleHook(orama.beforeRemoveMultiple, orama, docIdsForHooks);\n    }\n    await new Promise((resolve, reject)=>{\n        let i = 0;\n        async function _insertMultiple() {\n            const batch = ids.slice(i * batchSize, (i + 1) * batchSize);\n            i++;\n            if (!batch.length) {\n                return resolve();\n            }\n            for (const doc of batch){\n                try {\n                    if (await remove(orama, doc, language, skipHooks)) {\n                        result++;\n                    }\n                } catch (err) {\n                    reject(err);\n                }\n            }\n            setTimeout(_insertMultiple, 0);\n        }\n        setTimeout(_insertMultiple, 0);\n    });\n    if (!skipHooks) {\n        await runMultipleHook(orama.afterRemoveMultiple, orama, docIdsForHooks);\n    }\n    return result;\n}\n\n//# sourceMappingURL=remove.js.map"],"names":["OBJECT_COMPONENTS","FUNCTION_COMPONENTS","async","runSingleHook","hooks","orama","id","doc","hooksLength","length","i","runMultipleHook","docsOrIds","runAfterSearch","db","params","language","results","runBeforeSearch","createInternalDocumentIDStore","idToInternalId","Map","internalIdToId","save","load","store","raw","internalDocumentIDStore","clear","set","push","getInternalDocumentId","internalId","get","currentId","size","toString","getDocumentIdFromInternalId","Error","kInsertions","Symbol","kRemovals","_globalThis_process","warn","globalThis","process","emitWarning","message","options","console","code","trackInsertion","queueMicrotask","undefined","trackRemoval","remove","skipHooks","result","index","docs","data","documentsStore","docId","docsCount","count","beforeRemove","indexableProperties","getSearchableProperties","indexablePropertiesWithTypes","getSearchablePropertiesWithTypes","values","getDocumentProperties","prop","_orama_index","_orama_index_beforeRemove","_orama_index1","_orama_index_afterRemove","value","schemaType","call","tokenizer","afterRemove","sortableProperties","sorter","getSortableProperties","sorting","sortableValues","removeMultiple","ids","batchSize","docIdsForHooks","map","beforeRemoveMultiple","Promise","resolve","reject","setTimeout","_insertMultiple","batch","slice","err","afterRemoveMultiple"],"sourceRoot":""}